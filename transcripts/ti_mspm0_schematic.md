# KiCad 9 Hardware Design Tutorial (TI MSPM0) (1/2 Schematic)

00:00:00 - Introduction
00:01:38 - KiCad 9
00:02:14 - MCU Choice
00:03:24 - Code Composer Studio (CCStudio)
00:04:13 - JLCPCB (AD)
00:05:26 - Project and Schematic Creation
00:07:08 - Adding Components
00:08:29 - Creating Schematic Symbols
00:24:09 - Adding MCU to Schematic
00:25:45 - MCU Power & GND Connections
00:34:44 - Analog VREF
00:00:39:31 - Net Labels
00:41:19 - NRST
00:46:02 - Oscillators
00:57:00 - USB Connector & ESD Protection
01:04:08 - Power
01:11:50 - USB Continued...
01:14:46 - Debug Interface
01:20:56 - Pinout Planning/Assignment
01:27:06 - USB-UART IC
01:35:35 - I2C Peripheral (Accelerometer)
01:41:35 - Schematic Clean-Up
01:45:51 - Net Classes & Colours
01:48:12 - Electrical Rules Check (ERC)
01:51:18 - Footprint Assignment Tool
01:52:07 - Mounting Holes & Fiducial Markers
01:54:54 - Outro/Next Video

Transcript:
(00:00) In this video, I'd like to show you how you can use KiCAD 9 to create your own microcontroller board from scratch. The particular board you're seeing here, and one we'll be recreating, at least in certain parts, is this Texas Instruments MSPM0based printed circuit board, or PCB for short.
(00:20) Rather than looking at STM32 based microcontrollers, as we do in many other videos on this channel, we will be looking at this microcontroller from Texas Instruments, and we'll go through their product catalog in just a bit. Added to that for this particular PCB, I've also added in a UART to USB adapter or converter IC on the lefth hand side, which interfaces to a USB type-C connector, which is also the main power source for this board.
(00:43) We need a couple different components to get this MSPM0 microcontroller up and running. For instance, some various bypass and decoupling capacitors, an external crystal, as well as some configuration and bias circuitry, and of course, a programming port. And in this case, we'll be using a serial wire debug port or S SWD for short.
(01:00) And this particular little no solder header is from TAC connect, but we'll go into detail on that a bit later on as well. Given that this is a demo board, this is very very generic. So you should of course adapt it to your very specific needs depending on what your project requires.
(01:18) But hopefully this video gives you enough information to incorporate different types of microcontrollers and their supporting circuitry on a printed circuit board. We'll look at both the schematic, the PCB design, and then also how to export the various manufacturing information to get this board assembled and manufactured. And in this particular video, I'll show you how to do that with JLC PCB.
(01:35) Again, a very generic demo board, but hopefully it should give you a nice introduction to the entire hardware design process. I'd strongly suggest following along, pausing the video as you need to, and really trying to do this this design on your own and not doing a strict copy of this video. I find this is the best way, at least for me, that I learn is by applying, for example, tutorials or things I read for my own very specific designs rather than doing a onetoone copy. But of course, I'll leave the final decision up to you.
(01:59) What you need if you'd like what you need if you'd like to follow this video is to download KiCAD, which is a free open-source PCB design software. If you go to keycat.org, you can download this for Mac, Linux, and Windows. And currently, this is on version 9, which we'll be using in this video.
(02:17) In terms of the microcontroller, this is an ARM Cortex M0 Plusbased microcontroller. Texas Instruments has various number of different microcontroller types, entry-level, more advanced digital signal processors, and so on. And I'll leave some links in the description box below if you'd like to check those out.
(02:35) The particular M0 Plus line of MCUs we'll be using this video, you can look at TI's product category and search for the particular microcontrollers you would like to use. For instance, they're very inexpensive by controllers, which of course don't have as many peripherals, lower maximum clock speeds, lower flash and RAM sizes, but you can go all the way up to an 80 MHz core frequency part with a fair amount of flash memory, RAM, and quite a number of peripherals.
(02:57) So, I'd strongly suggest checking that out to choose the specific MCU that you require. In this particular video, we'll be looking at the MSPM0 G3507 SPTR, which is quite a mouthful, but you can read up the specs online. It's a fairly generic part, not the most powerful, but not the least powerful either.
(03:17) Quite a number of peripherals such as ADCs, DAXs, it can handle CAN, what's various timers, UARTs, and so on. We will be referencing this data sheet which you can find on the texturous instrument page as well as code composer studio which is the accompanying IDE that you can use to develop for and with TI's microcontrollers. CC Studio is free to use.
(03:41) There is an online version but I prefer using offline version which you can access by going to downloads and then clicking on download options. I really hope this video is useful and if you do find it useful, I'd kindly ask you to share this video with people who might appreciate this as well and also subscribing to the channel, leaving a comment if you have any questions. I really would appreciate your support in sharing this video and getting this video out there.
(03:59) I do have also many other videos on my channel covering embedded systems design, firmware, hardware, PCB design, digital signal processing, and much much more. There are quite a number of videos on this channel that hopefully help you out in your career or during your uni courses or if you're just doing this as a hobby of course. As well, a huge thank you to JLC PCB for sponsoring this video.
(04:18) I've had these MSPM0 PCBs manufactured and assembled by JLCPCB, and they did a fantastic job. As usual, I'll be guiding you through the ordering process at the end of this video once we've completed this design. And you'll see they're super easy and affordable to use. If you'd prefer someone else to do the layout and PCB design, JLCPCB actually currently offers layout services that help you through the PCB design process.
(04:45) Various different types of boards, high-speed, highdensity designs, and it's ideal for people who have a schematic but lack the time or interest to design PCBs, engineering teams that want to focus on product development and leave layout to experts, and anyone else looking for a fast, reliable, and time-saving one-stop solution. It's very easy to get a quote.
(05:03) Simply click on place orders, fill out the various information that you know about your PCB requirements, and you can very quickly get a quote back from JLCPCB. JLCPCB's layout service provides a skilled engineering team with experience in high-speed, high density, and multi-day designs. Their seamst integration with JLCPCB manufacturing and assembly, of course, full confidentiality for all of your projects.
(05:22) JLCPCB also often has coupons available, and I'll leave links to them in the description box below. With KiCAD downloaded and installed, you're greeted with the typical KiCAD home window. The first thing you want to do is create a new project. So go to the top left, file, new project. Then give your project a sensible name and click on save.
(05:41) Now we've got a couple of options. Effectively, this menu is in order of your what you might want to do. We want to start with a schematic. Occasionally might want to create our own schematic symbol. Then we move over to the PCB where we also might want to create a footprint. We can view Gerbers and we have a few other calculators which can be helpful in certain scenarios.
(05:58) Let's start off with the schematic editor by clicking on the top button. And here we are create greeted with this empty schematic page. I can use my middle mouse wheel to scroll in and out or zoom in and out. If I click down my middle mouse button and drag, I can move the page around. And if I leftclick and hold and I can select various components as we'll see later.
(06:16) The first thing I'd like to do with a new schematic page and we'll just create a single schematic page project for this video is fill in the title block which you can see on the bottom right hand side. So give it your project a title, add in the date, what revision this is and so on.
(06:32) The way you can do that is go to the top left and click on page settings. You can also change the page size orientation and so on. Here issue date. I can click on these left arrows to just fill in the current computer date revision. This is revision A. And we'll just give this the same title as the project. Fill in the company information or your name. And this is the minimum information I would expect on a schematic title page. There we go.
(06:51) If we click okay, this is now filled in. And then we've get those basics out of the way. What you want to do is add in a microcontroller, the various surrounding circuitry that this microcontroller requires such as a power source, maybe a USB connector and a USB to UR converter, programming interface, and of course some I/IO, just some generic IO.
(07:08) So you can see how we can do the pin mapping. The way we can add components in KiCAD is on the right hand side. You can see this little opamp symbol on the right hand side. Play symbols. I can click on that or I can just press A on my keyboard. So if I click on play symbols, it'll load the symbol libraries.
(07:25) And KiCAD comes with a lot of default or pre-made symbols and footprints that you can use straight away. And this is incredibly useful also just for passive parts such as resistors, capacitors, and inductors. But they do also have many different components. For example, processors, memories, and so on. You can use the filter box to the right at the top.
(07:42) So if I'm looking, for instance, for an op amp, I can just type in this particular op amp that I know. Click on this and I can have a preview of the schematic symbol. And I can also have a preview of the various footprints that are available for this part. And this is already made for you. Same for resistors.
(07:59) For example, if I just type in R in the search bar, I can have this resistor symbol come up. There are different symbols available depending on your preferences as well. We typically will just go with this standard resistor symbol. Same for capacitors. If I type in C, we have a capacitor or an inductor L and so on. Now, for us, if we type in MSP M0, there is a symbol available.
(08:18) But as you can see here just above, it's actually my own symbol which I made specifically for this design because of course I've made this design previously to make sure that it works before presenting you with a tutorial on this. So the MSPM0 actually isn't part of a standard KiCAD library and we have to make this schematic symbol oursel.
(08:36) And it might seem a bit daunting if you haven't made your own schematic symbols, your own footprints initially, but this is one of the core skills you need as a hardware designer because you constantly have to be making your own schematic symbols and footprints. I would strongly advise against using pre-made ones with the exception for maybe the KiCAD library. That is fairly good.
(08:53) But don't just go downloading symbols and footprints off the internet. They often times wrong. They often times don't have unified ways of displaying the information. They might not adhere to certain standards. So please create your own schematic symbols and footprints.
(09:11) And of course, I'll show you how to do this before we can proceed because this is our core piece, our centerpiece of the design. Let's go ahead and make this symbol. So I'll click on cancel. And what we want to do is go to the top toolbar and this little opamp symbol with a pen next to it is the symbol editor. If I click on the symbol editor, this opens up a new window.
(09:28) You could also get to the symbol editor by going back to the main KiCAD startup page which is always open in the background and then simply clicking on symbol editor. It's the same thing. In any case, with the symbol editor open, we can see all the libraries on the left hand side. We can create project-based libraries, that is local libraries or global libraries. What we want to do is go to file at the top left.
(09:46) Click on new library and here we can choose global or project. I'm just going to make this a project based library and click okay. Now we need to give this project library a name. And I'll just call this MSPMO tutorial schematic symbol lib. Not the greatest name, not the worst. Click on save. And that's now added to the libraries on the lefth hand side.
(10:05) But keep in mind because I selected project library, this will only be included for this particular project rather than globally. Once we've created our project library, I can right click on our library and click new symbol. Or I can go to the top left and do the same thing with this new symbol icon, new symbol. And we have to fill in some information.
(10:22) First of all is the symbol name, which is basically the part name. In this case, the part name I've just simply copied over from the Texas Instruments web page. It depends on what microcontroller you use. This is the full part name, and I'd suggest you use that for that specific symbol you're using.
(10:39) If the schematic symbol is similar to another part, you can of course derive that from other parts, but we won't do this. The default reference designator. So you see this in schematics. If a resistors labeled R1, R2, R3, and so on. Capacitors C1, C2, and C3 and so on. And typically integrated circuits will either be IC, but I prefer U. So it'll be U1, U2, U3, and so forth. We'll make this into a single schematic symbol unit. So that's why this stays at one.
(11:02) And we want to leave the rest as default. And simply click okay. Now if I zoom out again the mouse wheel on your mouse you can zoom out drag with a mouse wheel pressed down to move around. Let's create our symbol. There are multiple ways of creating the symbol. First of all we want to create the pins themselves.
(11:20) So the connections that is power pins, ground pins, IO pins and then we want to maybe draw a shape around it. For the case of an integrated circuit that typically is just a rectangle. We have a toolbar on the right hand side where we have the draw pins button and we can also press P on our keyboard. We click on this button.
(11:37) We can now give this a pin name, a pin number, what type of electrical interface this is, the graphic style, the position, pin lengths, and so on. This is one way of doing it, which is completely valid. But of course, we have about 64 pins on this device. And just imagine pressing P and going through this menu over and over again 64 times. That is quite tedious.
(11:56) If I click on cancel, there's another way of doing this by going to the top left or top middle, this toolbar, and looking at this pin table button. And if I click on this, we have essentially the same interface, slightly more condensed, but now we can add multiple pins just by clicking the plus icon on the bottom. So I can click plus and add various pins.
(12:15) And I can more quickly edit my schematic symbol like so. I can immediately type in the number, name, electrical type, graphic style, and so on. So that's what we're going to be using to actually create this schematic symbol for this microcontroller part. Now, of course, we need to know where we can get this pin information from. And of course, the usual place is the data sheet.
(12:31) The data sheet you can get on the manufacturer's website typically. And here I have our part and the data sheet in PDF format. I can just click and open that which tells you of course about the part itself. The various peripherals it has, the various power requirements are all listed in this data sheet.
(12:48) This is something you should always be checking out as a hardware designer. If you go to the table of contents, you can see section six lists the pin configurations and function section. So if I click on that, that's on page seven. we can see for the particular device we're using which is an LQFP type and I can get that just by looking at the part number and then the package type. So it's an LQFP with 48 pins.
(13:11) So this is the 64 pin variant but we're looking for the 48 pin variant which we have here. There also many other different package types such as these QFNs but we want a QFP 48. This is exactly where we can then get the pin names from and the pin numbers. So pin one is PA n FCC in PA1 PA2 and reset and so on are all of the microcontrollers pins.
(13:34) If you haven't seen microcontroller pins before it might seem a bit odd why do these have these slashes and these different names. Typically and simply speaking PA n PA1 PA28 are part of the A bank of pins and in the A bank we have the zerooth pin the first pin 28th pin. So these are fairly generic IO but not all pins can do all functions. So some you might be able to put timers on, some UART, some SPIs and so on. But we'll see where we can find that later on.
(13:57) The N reset pin is a dedicated reset pin of the mic controller and the N indicates inverted logic. So if I pull this pin to ground to logic low, that puts this mic controller reset state. If I pull this pin high, it takes it out of the reset state. Then we might have other multifunction pins.
(14:18) So for example, pin five can be a generic IO, but it can also be a certain clock output. VDD is typically the the positive power supply. So in this case, this might be our 3.3 volt supply. And VSSs will typically be our ground. So our 0V reference. And like this, you can go through this IC and carry that over to your key card schematic symbol editor. For actual explanations of the pins, we can scroll a bit further down in the data sheet.
(14:41) For instance, starting on page 11, section 6.2, we can look at the pin attributes. We can see which of these pins are standard drive, which ones are high drive, which ones are 5V tolerant or open drain, and what the IO structure or the type of pin is in this table.
(15:02) On the right hand side, you can also see we have in these columns the various different package types. So, we have to make sure we're looking at the correct package for our schematic symbol. And that's the second column of this subset of columns 48 pin LQFP type package. We can see pin six is VDD and that's of course a power pin. Pin 7 is VSSs and that's a power pin. And we can then also go through the various IO pins.
(15:22) So remember we talked about PA N which is in the A bank the zeroth pin and that happens to have digital functionality such as this can be a UR transmitter. It can be the data pin of an I squed C line. It could be a timer channel.
(15:40) it looks like it could be some sort of clock in and also the IO structure is that it's 5V tolerant. So in this way I would go through this data sheet and move that over to KiCAD. So having this side byside view here the symbol editor on the left hand side again going to the pin table in the top toolbar. Now I can add a pin. This is pin number one. The name is PA n.
(16:00) My electrical type I will change to birectional because this can be a transmitter. It can be a birectional receiver a timer input output. That's why I'm going to give it the electrical type birectional graphics style line and so on. Then I'll add my second pin pin 2. That's going to be PA1 and so on. You don't have to do them order, but of course I'd suggest you do them in order from 1 to 48 in this particular case.
(16:24) But for instance, if I add a power pin, for example, VDD that is on our 48 pin LQFP package, that's pin 6. I could say this is pin 6. Give it the name VDD. Then of course, it wouldn't be a birectional pin. This is a power input pin. This part requires power. It's an active part, so it's a power input pin. And so on. I'd fill in my symbol table and then click okay.
(16:44) And then I have these pins populated. Of course, not the whole part. I'd strongly suggest doing this in your own time on your own. You have these pins on the board. If I can left click on one of these pins, press M on my keyboard, and let that lets me move around these various pins. If I press R, I can rotate these pins by 90Â°.
(17:03) So, my power will typically my positive going power will typically be pointing up. I'll put my IO pins on the left and right hand sides of this package. I'll have my grounds pointing down and so on. When you're placing these parts, it's incredibly important to stay consistent with your grid.
(17:20) I'd strongly suggest if I double click on one of these components in one of these pins, we can bring up the pin properties table. And you can see the pin length is at 100 ms. There is this odd intermix of imperial and metric units. When it comes to PCB and hardware design, you'll often times when we go into the board, we'll move to millimeters, but often times the schematic based symbols and lengths are typically in mills. So that's thousands of an inch. The pin length is 100 mil and I'd suggest you stick to that.
(17:44) And I'd suggest you'd also stick to a grid of 100 mil. The way we can change the grid, if you look at the bottom side on the screen, we can see there's a grid 50 ms. I can press the N key and that changes the grid. So now 25, press N again, that's 10, and grid 100.
(18:03) So I'd strongly suggest sticking to an 100 mil grid anytime you make any changes in schematic symbols and schematics themselves. And then M again to move. And this is now on a 100 mil grid. And I'd align it in a very sensible way. Rather than making me go through this whole thing again, I'd please suggest you do this in your own time. And I'll just be using for the sake of time the schematic symbol I already created.
(18:24) And that's under the Phil's lab symbols KiCAD V9. If I open that up, we can see here I've already created the schematic symbol. I have all of my IO pins left and right. So I've got my A bank on the left. I've got my B bank on the right. I've got the N reset which is our input. I've got ground at the bottom which is a power input and my various power inputs and outputs at the top.
(18:44) So we have VDD which is our nominally 3.3 volt input. V core is actually a regulator output as part of the MSPM0 and that's internally generated but it does need some bypassing and decoupling capacitor in the output as we'll see later. I've then drawn this box around it this rectangle.
(19:01) And the way you can do that is go to the right hand side and click on draw rectangles and simply just draw a rectangle. Press escape to cancel the command. If I click on the rectangle, either double click or click once and press E, that opens the option. I can change the color. I can change the border width. I can fill it with body background color and so on.
(19:19) That's how you can get this typical keypad symbol shape. When placing your schematic symbol, I want to have my schematic symbol designated as a default, the top left, my schematic symbol name on the top right, for instance, or bottom right. and that'll be displayed on the schematic later on. I also want to align the top left of my symbol.
(19:38) You can see this corner is aligned directly with this origin of this grid. And that just keeps consistency when you're creating schematic symbols. You might have already noticed there's also some text on the bottom right hand side. This text on the bottom right hand side is actually part or displayed as part of the symbol properties.
(19:56) If we go to the top next to the pin table icon, we can see the symbol properties icon. An op amp with this cog wheel next to it. If I click on that, that lets me open the symbol properties. We can see the reference designator that's defaulted to U. We can see a value and we can see a footprint.
(20:16) The footprint itself we can designate as part of the schematic symbol. We have a schematic symbol, but that of course needs to map to a footprint to a component that we put on the board. The way we can do that is that way we can assign that is by going to the symbol properties panel. Clicking on footprint and you can see this little library icon these kind of books on the right hand side.
(20:33) If I click on this that opens the footprint chooser. And again from the data sheet we saw what footprint that is and that happens to be an LQFP-48 style package. You have to keep in mind however there are many many many different types of LQFP48 type packages. Just because it's called LQFP48, it doesn't mean that it's LQFP48 for Texas Instruments is the same as ST STM32 is the same as I don't know what manufacturer.
(21:05) So you have to really double check if that footprint already exists to check with the data sheet if the dimensions are correct. We want the LKFP 48. That's a 7x7 mm package with a pitch, so a pinto-pin spacing of 0.5 mm. And that is actually the correct package. And I've verified that with the data sheet. You can check that out in the data sheet by going to the table of contents going to section 12 mechanical packaging and orderable information.
(21:27) That's happens to be on page 89 or at least starting on page 89. And here we can see the LQFP. This is a 64 pin package. These are the mechanical dimensions. It's the recommended footprint. And we can of course also see the version we require which is the 48 pin package. We can see we have ranges of the dimensions. So the width and length are 6.8 and 7.2.
(21:46) That's nominal 7 mm. We can see the pinto-pin spacing. The pitch is 0.5 mm and we can see the recommended footprint given by Texas Instruments which is given here. The one we have in KiCAD matches this footprint very well. So that's why I went ahead and used it.
(22:04) But of course I strongly suggest going with whatever the manufacturer recommends at least when it comes to the recommended footprint. But this is the one I use because it matches the TI's recommended footprint rather well, the LQFP48. But this is something you should really pay attention to. After reference, value and footprint, you have various other parameters you can fill in.
(22:20) And I'd strongly suggest you do fill them in because it makes your life so much easier when you create your own schematic symbol and footprint libraries by populating relevant information. It doesn't have to be terribly much, but there's a certain minimum I would recommend. That is add in a link to the data sheet. Add in a brief description of what this part is.
(22:36) It helps you with your search rather than this MSP M0 G3507. That doesn't ter tell me terribly much about what the hell this actually is. It's my controller. this certain core, this certain max clock frequency, flash and RAM sizes as a bare minimum. Then once we get to manufacturing later on, we want to be able to tell our assembly house, in this case JLCBC, what part they need to assemble.
(22:59) For that, they need to know the manufacturer, Texas Instruments, the manufacturer part number, this MSPM0 part, and I like to provide at least two distributor links where they can source these parts from. Distributed link one I do Mouser. Distributed link two I do Digi Key. And then I also add in an LCSC part number. LCSC is effectively a part of JLCPCB.
(23:18) And when you order with JLCPCB, they will source their parts or they can source their parts mostly through LCSC. So I've typed in the part number here. Click on search. And this number that you can see underneath the part number is the LCSC number. And this is super helpful to add in if you do a lot of assembly and manufacturing with JLCBC. And that's exactly what I do.
(23:36) So, I added an LCSC part number, and this is the minimum information I would recommend you put in to your schematic symbols. It's not terribly much, but it's it's very very helpful in all stages of the design. In any case, that's why all of this information is displayed in this grayed out text.
(23:54) This will not be visible on the schematic because we've we've hidden these parameters. This is how you very simply create your own schematic symbols. It might seem daunting initially. It might seem very boring, but trust me, it's worth doing this yourself. You can save the part just by clicking save all on the top left hand side. That also saves your libraries. And then we can close the symbol editor.
(24:11) With our symbol created, now we can finally add it to our schematic. Again, we can go to the right hand side, click on play symbols or simply press A on our keyboard. If I click this button again, we want to search for our MSPM0. And I'm just using the one that I created previously. Select it and click okay. That closes the dialogue box.
(24:31) And you can see the origin because we've placed the component to be an origin 0 0. Our grid we changed by pressing N. You can look at the bottom right hand side of the screen. There's the grid now 25. And we want the grid to be 100. Always stay on 100 mil grid. Do not deviate from that. I really strongly suggest that. Mouse wheel to zoom in.
(24:49) And let's place the part somewhat centrally. Click to place. Escape to cancel the command. Middle mouse button clicked and drag. I want to move my designator around. So you can see KiCAD has automatically annotated the designator. So rather than doing U question mark, it's now called this part U1. If I click on this, press M, I can move this designated to the top.
(25:08) Same thing with the MSPM0, which is our part name, part number. I'll just move this to the top for the sake of cleanliness as well. Now we have our single microcontroller on the board. And this is already one of the biggest schematic symbols. What we want to add around it is all this circuitry that is required.
(25:25) So we need a USB connector which is going to be our data connection plus our main input power source typically at 5 volts nominal. But this microcontroller doesn't run on 5 Vs. So that's why we have to step the input voltage 5 volts down to provide 3.3 volts to the VDD supply. We need various surrounding circuitry. We need a programming interface which is serial wire debug in this case.
(25:42) And we might want to expose just some various IO. So we need to add in our surrounding circuitry. With our microcontroller symbol in place, now let's add in first of all the supporting circuitry that's very very dedicated to this particular microcontroller. It's not terribly much and you can reuse this across these types of microcontrollers, but of course check the data sheet in case you go to a more complicated microcontroller. Add in the power and ground symbols.
(26:05) Where you can do that is go to the right hand side underneath the place symbols we have the place power symbols button. We can also just press P on our keyboard. Let's click on that and we can see the view that opens up. If I expand this power section, we can see there are some predefined net labels or power flags, power symbols.
(26:23) So, 1 volt, 1.1 volt, and so on, as well as 3.3 volts. And if we search in the filter on the top, let's type in G and D, we have our ground symbol. So, this is our 0 volt reference. I'll click on the ground symbol, double click or click and press okay. That selects it. I can move it around as usual.
(26:41) And I'll place it on my VSSs pin like so. If I press escape, that cancels the command. And like so, we've connected our VSSs pin, pin 7, this mic controller to ground, which is one of the connections we need to make. I typically don't like showing the ground symbol. For me, it's obvious unless I have multiple different grounds.
(27:01) So, I can double click on this symbol and click uncheck this checkbox, show next to the value. Click okay, and that hides the ground symbol. At the top, we need VDD. That's our 3.3 volt input voltage source. Going to the data sheet, we can see for this microcontroller that the supply voltage can range anywhere from 1.62 to 3.6 volts.
(27:19) So if you have any other particular reason, I'd suggest just going around 3.3. That's a pretty standard voltage. The core voltage, which is internally generated by the MCU as normally 1.35 volt. And the terms of capacitance we need bypass decoupling capacitance for CVDD is 10 microfarads. And for the core voltage, we need a 470 nanofarad capacitor. So let's implement that on the schematic.
(27:40) On the right hand side, I'm going to place a power symbol or press P on the keyboard. I'm going to look for plus 3v3. I much prefer writing 3v3 rather than 3.3 because the dot easily gets lost in the schematic. I find this is a far clearer distinction to me. So that's why I go with 3v3. I can place the symbol like so.
(27:59) Because the command is still active, I can click again and that opens up the power symbol. As before, I can add in plus one v. And there we already have a plus 1V35 symbol. Click okay to add that in. That's going to be our core voltage. Press escape to cancel the command.
(28:17) If you do need a different voltage, you can just doubleclick on the power symbol and just change the value in the value field. That's completely fine as well. As we saw from the data sheet, we need some decoupling and bypass capacitors. And the way we can do that is add a part again right hand side or press A. Type in C into the search bar and we've got a capacitor. So that's what we want. It's an unpolarized capacitor. We'll be using a multi-layer ceramic. Click okay.
(28:36) I can press R to rotate. I'll just keep it vertical for now. Double click on this to change the value to 10 U. So that's 10 microfarads. We don't need to write 10 UF. The F the farads are implied because it's a capacitor. What else could it be? When you add in the capacitor, you have the option of assigning the footprint straight away.
(28:54) This is good because then once you've assigned this for one part, you simply have to copy the part in the schematic and all of the information, the value, the footprint, and any other parameters you add to the symbol are automatically copied again. So you don't have to type it over and over and over again. So that's what I'd like to do.
(29:12) And this also alludes to why I strongly suggest even though KiCAD has these built-in symbols, you can see these symbols are empty. The footprint is empty. We don't have any manufacturer part number. We don't have any distributor links. Every time you create a project, you would have to create this again.
(29:29) So, I'd strongly urge you make your own schematic symbol libraries and populate the information so you don't have to do this over and over and over again. I'll show you how to do this once. Footprint, I'm just going to click on the little book icon on the right hand side and it immediately applies the footprint filter. And there's any different package types that that are available. For capacitors, you typically will have them listed in imperial sizes.
(29:46) So, 0201, there's 042, 0603, 805 and larger. For a 10 microfarad capacitor, as a rule of thumb, we are running with very low voltages, so it's not that important, but I typically go with maybe let's say an 0805 size capacitor. And this is just from experience. This is a fairly large capacitor size.
(30:06) 10 microfarads is quite a large amount of capacitance for these small multi-layer ceramics. So you want to increase the package size to at least a tiny bit miticate issues with derating. That means when you apply a DC voltage across this capacitor, the capacitance value actually drops. And you can kind of mitigate that a tiny bit. Depends on the part of course by choosing a larger package size.
(30:23) So a 10 microfarad just from experience an 085 capacitor for this 303 volt supply is okay. So I double click on CO85 and that assigns the footprint. Then we want to click add field because we want to add in the manufacturer manufacturer part number, distributor link one, distributor link 2 and LCSC part number as we saw with the MSPM0 microcontroller. You can also keep this to the end but again please create your own schematic symbol libraries.
(30:47) The part I've chosen is this Samsung 10 microfarad 0805 capacitor. You have to take in mind, keep in mind the voltage rating. So I'd suggest this be at least double the maximum voltage DC voltage you expect on top of the part. So we're running at 3.3 volts. So you might want to go with a 10V minimum rated capacitor. Again, keep in mind derating which means the capacitance drops as you apply DC bias.
(31:11) We also have the type of capacitor. So that's multi-layer ceramic, but this happens to be an X5R type. These characters give you information on the various temperature change and bias characteristics you can expect. X5R, X7R are very typical for these kind of bypass decoupling applications. You can see the tolerance 10% is completely fine.
(31:29) The actual value doesn't really matter terribly much for this part size and so on. So that's all in description, manufacturer, manufacturer part number, distributor links, and LCSC number. The reason I chose this part other than of course the specs itself is because we're getting this manufactured to JLC PCB. And I'd always strongly suggest choosing basic parts if you can from their category because these are cheaper to assemble.
(31:48) They are already on JLC PCB standard reels pick and place machines. There isn't an extra search charge compared to using other parts. And for Jellybean parts such as this, that's typically completely fine. So that's why I chose this particular part. But as you can see, typing this information in from scratch every single time is pretty tedious.
(32:07) So please make your own schematic symbol libraries with this information contained and you won't have to do this more than once. Click okay. And that saves this C1 part with its information. Now, if you want to tie this to our 33 volt net, I can click on my 3.3 volt symbol, move it just above. You can see if I hover over a node, I get this little pen or this little drawing icon.
(32:26) I just simply have to click and click again on the next node of the capacitor. And that creates this net connection, this wire between our 3.3 volt power symbol and C1. I can go down and simply drag over Ctrl C and Ctrl +V to place my ground and simply hover over to draw a wire between my ground power symbol and my capacitor other side.
(32:51) Then I can just simply click and drag and you can see the wire just follows along because I need to of course connect this connection to VDD. The way I can do that is simply hover over VDD and click again. And then that creates this little junction which is a three wire junction which now connects VDD to our decoupling capacitor and 3.3 volts. I can hover over this symbol because I want to move it down a bit.
(33:08) There we go. Now I suggest you try this now with a 1.3 vol net and VDD core. And remember this requires a 470 nanofarad capacitor. Please try this now in your own time to attach a 470 nanopharad capacitor as we just saw similar to the 10 microfarad capacitor.
(33:27) Once you've added in the 470 nanopharad capacitor, attached the 1.35V core net. This should look something like this. So, exactly the same procedure as before. What you could have done is also just clicked and dragged, selected everything, Ctrl C and Ctrl +V, and then you can hit X on your keyboard to mirror along various axes.
(33:47) So, Xaxis and Yaxis you can flip by using X and Y on your keyboard. Then, of course, you need to adjust the properties of C2. So you can either double click on this, select it and press E to open up the properties panel. This is a far smaller capacitor at only 470 nanofarads. That's why I used a smaller footprint. I use an 0603 imperial size footprint.
(34:04) I've edited all of the other information as well. So now we have our basic bypass and decoupling in place. Of course, we still need to add in the power sources later on because only the 1.35 volt rail is generated internally by the MSPM0. We also need the 3.3 volt step down from our 5V USB input.
(34:22) But there's also some other circuitry that we need to implement. This particular microcontroller does have internal oscillators, but often times it's useful to add an external crystal-based oscillator because these are more accurate which is needed for example for communication protocols such as USB UART and if timing is of importance. So I'll show you how to add an external crystal.
(34:41) You also need to add the debug interface and reset connections and so on. So let's add in the remaining circuitry. Other than the bypass and decoupling capacitors for VDD and V core, we also have various analog peripherals in this MSPM0 part. We can see that by going to the data sheet page four, which is the functional block diagram.
(35:01) And what we can see instance the ADCs, we have our reference voltages, inputs or outputs, whereas opamps, DAXs, comparators and so on, which are part of the analog domain. So rather than using for instance the VDD and and V core rails for those analog peripherals, we might want to use a slightly more quiet reference or supply.
(35:20) And for that, if we go back to KiCAD, we can see zooming into pins 39 and 43 that we have VRF minus and VRF plus pins. And these are either internally generated voltage references for the analog peripherals or we can supply an external voltage reference to increase for instance the accuracy or lower the noise floor of these internal converters and these analog peripherals.
(35:45) What we then need to connect is typically an external decoupling bypass capacitor between these pins and tie VRF plus and VRF minus to appropriate sources. Or if we use the internal reference, we might just need the external bypass capacitor. Again, going through the data sheet looking for VRF plus, we can see exactly that that we can either supply an external reference or use the internal reference.
(36:07) And we can see here when we're using external voltage reference, a decoupling capacitor must be placed between VRF and VRF minus. And VF minus is typically just tied to ground. In terms of voltage sources and levels for the external reference, we can go between 1.4 4 volts and maximally upped to our VDD supply voltage which in our case is 3.3 volts.
(36:25) If we're on the other hand using the internal reference we can go to a maximum VRF which is actually adjustable. I think it's between 1.4 and 2.5 volts if I'm not mistaken. We can also see the recommended VRF decoupling capacitor on the VRF pin with respect to ground or VF minus and that's between 0.7 and 1.2ish microfarads.
(36:45) Looking at the footnotes as well, we can also see also if we use the internal voltage reference, we need to be connecting the VRF plus and VRF minus pins across a decoupling or bypass capacitor. Now, normally we might want to use a 1 microfarad capacitor, but because at least for this design, we're not going to be using the ADC terribly much. This is a demo board and I want to keep my biller materials short.
(37:06) What we're going to practice is ber materials consolidation. And that way I'm simply just going to take C2 my 470 nanopharad capacitor which okay is about half of one microfarad capacitor but it's good enough for the purposes we need. Crl Ctrl +V and place that close to the VRF minus and VRF plus pins and then simply hook that up to VRF minus on one side and VRF plus on the other side simply by clicking on the nodes and that allows us to then draw wires.
(37:39) VRF minus typically should be connected just straight to system ground. So we could simply could copy our ground power symbol at the bottom for example from pin 7 and tie that directly to VF minus. But we can have a slightly more flexible approach is by simply placing a 0 ohm resistor which is a effectively a short at at pin 39 and then tying that to ground like so.
(38:04) That way we can remove the short by simply depopulating R0, our resistor, R0 and resistor. Let's do that. So the way we can do that is add a part by pressing A on our keyboard, typing R into the search bar, and then we can find our resistor symbol. Double click on that. Place that next to our decoupling capacitor. Press escape to cancel the command. Click on the node to draw a wire.
(38:24) And on the other side, I'm just going to copy my ground symbol. drag ctrl + ctrl +v and then click click to draw the wire. Then if I can I can either double click on R which is the value field and type in 0 R or 0 ohms. I prefer doing that rather than just writing a zero. So I'll if there's a 0 ohm resistor I'll add R at the end of it.
(38:48) And then of course double clicking on the resistor I need to add in my footprint, data sheet, the description and manufacturer part numbers and so on. The footprint we're going to stick with 0603 for the most part. So click on the library button and double click on R603. Remember to fill in in this this other information in your own time. Press okay.
(39:07) And this way we've hooked up VRF minus VRF plus to a somewhat appropriate amount of B decoupling capacitance. And we've enabled the option to tie VRF minus directly to ground through this 0 ohm or this short link. Keep in mind this is only really critical if you're using the internal or external voltage reference and the analog components within this MSPM0 part. You can get away with not using this at all if you're not using any of the analog components.
(39:32) At the top we saw we added our power symbols. We added a 3.3 volt. We added 1.3 volt which automatically if I click on one of these nets on the bottom left hand side we can see the connection name is automatically assigned to the power symbol net we've given it 1.35 volts.
(39:50) However, if we now go to the VF minus and VF plus pins, if I click on one of these wires, we can see the connection name is now not particularly pleasant. It's net- bracket U1 PA21, whatever. Now, this kind of tells you what it is, but it's not particularly pleasant when it comes to routting out and laying out the PCB design.
(40:08) We want fairly short, concise, clear names, and I'd strongly suggest labeling every single net in your design. It makes your life so much easier. It makes reviews so much easier rather than having these rather messy connection names. The way we can assign net names is by going to the right hand side and hovering over this little A symbol where it says place net labels or the keyboard shortcut is L. I'll click on this and that opens the label properties window.
(40:31) For this, I'm just typing the label VRF minus. Press enter or okay, and place that on top with this little square directly on our wire like so. Press escape to cancel the command. Now, if I click anywhere on this wire, this all belongs to the same net. We can see the connection name is now VRF minus.
(40:49) If we're looking at the bottom left hand side of our screen, much much cleaner. Immediately tells us what this net label is for rather than this weird U1-PA21, whatever. I can click on this, Ctrl + C, Ctrl +V, place this on VF plus, double click on the net label, and change the minus to a plus because of course it's not the same net. Press okay or enter.
(41:09) And now this bottom net is called VRF+ which we can see in the bottom left hand side. So please label all of your nets. It makes everyone's life so much easier and you'll see that when we come to the PCB design. Now we've got our main bypass and decoupling capacitors in place. We still need some various other supporting circuitry. It's not much.
(41:26) And this supporting circuitry is very similar across this family of microcontrollers. We need to connect up our N reset pin. Remember pulling N reset to ground. So logic low puts this mark controller in a reset state. Pulling this pin high and reset pin high puts the MCU into run mode in a typical case. Looking at the data sheet page 84, we can see a basic application schematic.
(41:52) And we can see the various connections we've done previously. So the Vcore and VDD, but we also have the end reset connection. And here we can see a pull-up resistor to our VDD voltage as well as a small filtering capacitor directly on the end reset line.
(42:10) And we can read here the end reset pull-up resistor and capacitor are optional but end reset must be pulled high to VDD for the device to start. So we need some method of pulling and reset high otherwise the device won't start. And that's why I would strong suggest to always add in this pull-up resistor. And we can see the magnitude of this pull-up resistor is in the order of tens of kiloohms. And we have a small 10 nanopharad capacitor. Of course the rise time of this lowass filter circuit.
(42:30) So this resistor with this capacitor will have a certain rise time and that will delay the startup of this MSPM0 microcontroller based on this RC filter time constant. Unless you're designing for a very very specific application, this is usually not critical and we will be reusing parts we already have on the design. What you also see here is that they're paralleling a 10 microfarad and a 0.
(42:54) 1 microfarad capacitor for the VDD and VSSs lines. And I typically would recommend against doing that because paralleling these capacitors if they're in very similar package sizes, which they are, 06, 03, 08, 05 are fairly similar sized packages, that will just simply cause resonances in your power distribution network. That's a topic for a different video.
(43:12) And I actually have various videos on my channel discussing this. But I find it much better just to go with a 10 microfarad part, place it close to the VDD, VSSs pins, as we'll see later. And that's why I haven't done this paralleling of these two capacitors. In any case, let's implement this end reset circuitry.
(43:31) Going back to our schematic, we want a pull-up resistor to our VDD voltage, which is 3.3 volts. And we want a small amount of capacitance on the end reset line. So, I'm going to copy my R1, click on it, Ctrl + C, move over to the end reset side, put it somewhere close to the end reset pin, and just tie that up as usual. Clicking on the various nodes, copying the 3.3 volt flag, placing it down here, connecting it together.
(43:50) You can see the tools, the commands are pretty much always the same for drawing these schematics. Of course, we don't want a zero ohm resistor because this is tied directly to 3.3 volts. There's not going to be any time constant. Plus, later on, we will also be tying this N reset pin to our debugger or programmer connection because then the programmer can perform a hardware reset by pulling the N reset pin low.
(44:15) So therefore, that's why we also don't want a zero connection because then the debugger will not be able to pull the N reset pin low. We saw we want about 47 kiloohms of resistance for the R2 pull-up, but the actual value resistance, unless it's very very low or very very high, doesn't really matter. So, you could do anything from, let's say, 4.
(44:34) 7 kiloohms to maybe around 100 kiloohms as a pull-up is fine. I typically like to stay on the lower end of my pull-up resistor. So, for reasons we'll see later, I'm actually going to make this into a 5K1 pull-up resistor. So, I'm going to double click on the value field, type in 5K1, and press okay, or press enter. You can see the way I'm writing 5K1 rather than writing 5.1 kiloohms.
(44:54) Again, the units are implied because this is a resistor. So, we don't need to add in ohms. And I don't like putting dots in my value fields or any parameter on the schematic because they kind of blend in with the background. They are hard to see. That's why I like this format of doing 5k1 rather than 5.1 kiloohms.
(45:10) We also need the capacitor. And this capacitor is useful again for providing a somewhat controlled rise time start to this device as well as helping against glitches that might happen because of ESD events because of circuit events on the printed circuit board. So that's why we're going to add a bit of capacitance. They had 10 nanofarads.
(45:30) We are actually just going to copy this 470 nanofharad capacitor because again the time constant we've gone down in resistance for R2 and we're going up in capacitance on C4. I wouldn't go terribly much larger than this. um you might just want to go with 100 nanopharads or even smaller than this.
(45:46) But in this case, it's fine to have this amount of capacitance again for the reasons we mentioned previously. Later on, we're going to be tying this to the debugger programmer connection as well. But this is pretty much it. But remember, don't forget your net labels. Going to copy a net label, place it on the wire, change the net label by double clicking, and changing it to end reset. So we have sensible names for all of our nets.
(46:05) Now with this in place, this device has its own internal oscillator as we spoke about previously. It might not be terribly accurate. It could be okay for most situations, but if you want want to use a UAT interface, if you need precise timing, you typically will need an external crystal or an external crystal oscillator.
(46:23) And I'd like to show you how to connect one of these up just for the case that you need it. Before that, however, we spoke about this device having an internal oscillator. You can actually improve the accuracy of this by connecting an external trimming resistor and that you connect to pin 8 where we can see we have our OSC so our oscillator and you might have already seen this on page 84 where we have PA2 R O tied to a 100 kiloohm resistor to ground and this has very very tight tolerances and specs.
(46:48) So this has to be a plus 0.1% part with a temperature coefficient of 25 parts per million. This then can be used with a trimming routine in firmware later on to improve the accuracy of the internal oscillator. So, I'll show you how to add that in, but you should probably know how to do this by yourself at this point. We just have to simply add in a resistor.
(47:06) So, the way we can do that is just copy one of our previous resistors. I'm just going to rotate it by pressing R, place it close to the ROS pin, tie them together, and tie the other end by copying a grand symbol to the other side of the resistor. And of course, this needs to be a 100 kiloohm part with very, very specific properties.
(47:24) And the way you could find one of these parts is going to your favorite component distributor or manufacturer. I'm looking at thick film resistors SMD type where you want a resistance of 100 kiloohms, a tolerance of 0.1%, temperature coefficient maximum of 25 parts per million, package size of 0603 in imperial units. And of course, we want them to be in stock and apply filters.
(47:49) And you can see from the previous 500,000 parts that are available, there only seem to be about two parts remaining. And you can see they are comparatively fairly expensive resistors. In low quantities, they're tens of cents, which compared to a normal SMD resistor without these specifications, the 0.1% or 25 parts per million, these are fairly expensive resistors. So, one of these resistors might do.
(48:07) So, you would transfer over the information for this manufacturer, manufacturer part number, part description over to the schematic into that resistor we just placed on the OS resistor line. Don't forget your net label. Again, you can copy a net label or press L. And we want to call this a sensible name. So I'm just going to call it our osk.
(48:24) And that's sorted out that connection. But keep in mind this resistor can't just be any old 100 koohm. It needs those specifications. Otherwise the internal oscillator won't trim correctly. If you'd like to attach an external crystal oscillator, let's see how we can do that.
(48:41) Looking at the data sheet again, starting on page one, we can see we have options for attaching an external 4 to 48 MHz crystal oscillator. So, this is a high-speed external crystal oscillator and they call it HFXT. And you can also attach a 32 kHz crystal oscillator and that's a low frequency external LFXT crystal oscillator. You can also attach a SMOS oscillator on the external clock input, but it's typically cheaper to connect an external crystal.
(49:04) For most cases, you'll pretty much only need the high frequency external crystal oscillator. The low frequency external crystal oscillator is useful if you want to have real-time clock functionalities and so on. But for us, we're just going to be focusing on the HFXT. We can see the pins are HFX in and HFX out.
(49:22) If you want to use a crystal oscillator, a seamos oscillator, you would use the HF clock in pin. The high frequency clock parameters we can see here. We can see what various normal frequencies we have again anywhere from 4 to 48 MHz. We can see the integrated effective load capacitance of those HFXT pins is about one parad. And that can be good to know as well.
(49:41) Duty cycles if you're using the clock input. So around 50% nominal and what power supply ranges have you have for the crystal as well. But that of course is based on your VDD typically. The connections are fairly straightforward. Again, we just need the HFX in pin, that's pin 11, and HFX out pin, pin 12.
(49:58) We can add a part by pressing A, then looking for crystal. There are many different types of crystal packages. The typical package or typical SMD package for these high frequency crystals is the crystal ground to four package that has four pins. Pins one and three are connections to the crystal terminals and pins two and four are connections essentially to the the shield of the casing which are grounded typically.
(50:25) Click on okay to add this and I'll place it close to the HFX in HFX out pins. And somewhat arbitrarily I'm just going to make this into an 8 MHz crystal. I typically designate my crystals with X, not with Y. So I can double click and change that to X1 and change crystal ground to four to be the actual value of my crystal. That's only 8 MHz.
(50:44) And of course you have the usual spiel of adding the various parameters to this crystal part that is footprint data sheet manufacturer part number and the usual. We can already add the footprint together. So in the symbol properties click on the part press E or double click on it click on the footprint scroll to crystal SMD and typical SMD crystal packages the ones I like to use are either the 3.
(51:03) 2x25 mm that's this one or the slightly smaller package which is the Crystal 2520. So 2.5x20 mm. Either one of these is fine. You might find more options with the 3.2x 2.5 mm package. So let's click on that. Double click and of course fill in the rest of the information. And then press okay.
(51:22) Now the crystal itself of course has connections to HFX out and HFX in. And we can connect it up. For example, something like so. But of course we need to connect pins two and four to ground. But also the crystal itself needs load capacitors to a fairly low value in the poparad range of capacitors that can be used to shift the frequency slightly or to trim out calibrate the frequency of this crystal.
(51:47) The load capacitance that we apply on the pins of these crystals depends on the specifications of the crystal itself. I will be just skimming over the calculation in this video, but if you're interested, ST Micro Electronics has an application note AN2867, which is about a 60-page document, which tells you pretty much everything you need to know about using crystals and crystal oscillators in microcontroller based designs. Basic theory behind it, calculating drive levels, external resistances, and so on.
(52:09) But what we need to know is how to choose the load capacitance and what that is. That's in section 3.3, page 12. This actually tells you how to calculate the load capacitances which we need attached to the crystal pins. So for instance, I've picked out one of these crystals here. This is an 8 MHz crystal.
(52:28) It has tolerance of 20 parts per million and a frequency stability of 30 parts per million. And this tolerance and frequency stability you can get from the date sheet or your particular application requirements. For UART or for USB, you will have different tolerances and frequency stability requirements. This crystal is fairly good.
(52:44) But also for us importantly, it tells us that this particular crystal has a load capacitance of 12 poparads. To then actually get the capacitance we need externally. What we need to do is take our load capacitance of the crystal subtract from this an estimated stray or parasitic capacitance that we expect due to the component pins due to the way we've laid out and rooted the PCB.
(53:04) And that's anywhere in the range of 3 to 5 poparads. So take that subtraction result and multiply the whole thing by two and that's an estimate for the external load capacitance capacitors we need. So for example taking the 12 poparads subtracting five poparads multiplying by two we get an estimated load capacitance of about 14 poparads.
(53:23) If we estimate our external parasitic capacitance to be four it's going to be slightly higher at 16 poparads. So we might want to go somewhere in between and just choose for this particular crystal and again it depends on the particular crystal you choose. We might just want to choose a load capacitance of about 15 poparads either side of the crystal.
(53:43) What that then looks like is if I just copy one of these capacitor symbols or we just place a new one for pressing A. Place that in here. Double click on the value. That would be 15 poparads. Tie that to one side of the crystal. Copy that again. Place that on the other side of the crystal and tie the other sections to ground. Place that other side of the crystal.
(53:59) I'm just going to press X to rotate. Take a ground power pin. Crl + C crl + V and tie that up to the bottom sides of these capacitors and also to pins two and four of my crystal oscillator that these are grounded. The case is grounded. This is then what our structure would look like.
(54:18) We have our crystal connected with pins one and three to HFX in and HFX out. These are our main crystal connections. But the crystal itself needs these external load capacitors. Again, refer to the application node by SD Micro Electronics. And we've calculated for this particular ECS crystal for that particular part number with a load capacitance of 12 poparads.
(54:36) We should be in the right ballpark with 15 poparads. That's something you will of course have to verify and maybe trim out and tune out on the real PCB because we're just handwaving this 3 to 5 poparads of strain and parasitic capacitance. But this usually has worked out pretty well for me.
(54:54) I've rarely had to really tune my crystals and my crystal load capacitor values given that I've made fairly sensible assumptions and calculations like we just did. Don't forget the net names. So, press L. I'm just going to do HFX in for this net. Press again because the command is still active. HFX out. Place that on the other net.
(55:12) Sometimes you will also see on the output a series resistor which can reduce the drive strength to the crystal because if there's too much drive strength from the internal driver, the internal crystal driver inside the MSPM0 microcontroller that can overdrive the crystal which could lead to harmonics, frequency inaccuracies, but it could also lead to degradation of the lifetime of the crystal because you're driving it with too much power.
(55:36) Again, refer to the ST micro electronics app note because that tells you exactly how to calculate an external resistor value, how to calculate the drive strength, and what external component entries required. But often times you can fare fairly well, especially for the sake of this demo board, without an external series resistor.
(55:53) Keep in mind, some microcontrollers also require an external parallel, for instance, 1 megga ohm resistor between HFX in and HFX out because that sometimes isn't included within the microcontroller package. it happens to be for the case of this MSPM0 microcontroller and you can reference the data sheet you can reference various evaluation module boards to verify that is the case but don't always just take that for granted with all that being said however we now have pretty much all surrounding circuitry that is required for this microcontroller to run of course this won't do very much because first of all we don't even have a power source we have nothing that provides this 3.3 volts and it's kind of boring
(56:26) because we have no other connectivity we're not using any of these these other pins and I'd like to show you how you can get a pin out. For example, if you'd like to use UART or if you'd like to use I squed C or timers or whatever. I'd like to show you how you can figure out which pins you can use and which pins you should use for which purposes. We'll add in a USB connector.
(56:44) We'll add in some ESD protection. We'll add in a USB to UR converter and of course a regulator that steps down the 5 volts coming from the USB down to the 3.3 volts. And of course, our programming header as well. But this so far is the core of what you need in terms of peripheral circuitry for this microcontroller.
(57:02) With our main supporting circuitry for this microcontroller in place, we of course need to power this device and do something somewhat interesting with it. So, we're going to be adding a USB type-C connector, which will provide power. This won't be using any USB type-C PD, so it'll just be a nominally 5V power supply, which we need to step down to 3.
(57:20) 3 volts for the VDD supply of this microcontroller. and we'll add in a USB to UART converter IC because the MSPM0 microcontroller doesn't natively support USB. So, we're going to have to do some conversion between USB and UART and there's plenty of IC's out there that'll do that quite easily for us.
(57:39) So, let's start off by adding a USB type-C connector. The way we can do that is our usual. We add a part by pressing A or going to the right hand side menu. Then in the filter tab at the top I can type in USB and we can choose from various different type connectors. These are USBC type A type B type and many different ones. And we would like a receptacle.
(57:58) There are of course many different types of USB type-C connectors. There are ones with sideband use pins. There's ones for USB 3, USB 2. There's throughhole SMD. But for the schematic symbol, we typically farewell with a 16 pin USB 2.0 type receptacle. This has Vbus CC1 CC2 pins. The differential pair pins and in this case there's also sideband use pins which you don't actually need.
(58:23) But 16 pin connectors are fairly easy to find. So that's why we're going to go with this USB type-C receptacle. Keep in mind this is fairly generic. It's not actually assigned to a proper so to speak part yet and not assigned to a footprint. We have to do that manually unless you of course create your own schematic symbol and library. So I've selected this. I'm going to press okay.
(58:41) And we can pop this part down somewhere on the left hand side of the schematic. Press escape to cancel the command. And we can now look at this part. I'm not particularly happy with some of these KiCAD default layouts. For instance, I would like to have the CC1 CC2 pins below the differential pair because we're just going to be attaching some pull down resistors there and otherwise they would get in the way with these D minus D plus pairs. The way we can edit this symbol is by double clicking on it. And on the right hand side, we have various symbol
(59:05) editing buttons. One is edit the library symbol itself. So this will then work across projects. If you want to permanently adjust the library symbol, we can click on that button. But for this, I'm just going to edit the symbol itself because I'm not terribly much a fan of editing other people's and overwriting other people's libraries.
(59:23) I'd rather create my own schematic symbol and footprint. So, we're going to go on edit symbol. That'll bring up the symbol editor. And all we want to do is move the CC pins down below the D minus D plus differential pair. So, I can simply click and drag, press M to move, and move them down. And let me just make that a bit neater. And I'd suggest you do that on your end as well.
(59:42) For instance, an arrangement like this is I think a bit more suitable in my eyes. We have Vbus at the top, the D minus D plus differential pair for USB 2.0, CC pins and sideband use pins and ground and shield at the bottom. You can see also the little warning at the top that saving will update the schematic only and that's exactly what we want.
(59:59) So I'll press Ctrl S on my keyboard or you can go to the top left and click save on the little disc get icon and close this symbol editor. Now there we go. Now the changes are also reflected directly in the schematic. Vbus is normally 5 volts. That will be our power source.
(1:00:15) We need to connect this to a host PC which will then provide this normally 5 volts of voltage with a certain limit of power as well as a differential data pair. If the upstream device, the host we're connecting to actually uses USBC, we'll have to attach CC1 and CC2 to 5.1K pull down resistors.
(1:00:33) And that'll indicate to the host device that okay, there's a device attached and it has a certain power requirement. Typically for USB type-C, if we attach 5.1 koohm pull downs to the CC1 and CC2 pins, this means we can typically get up to about 1/2 amps at 5 Vs, which is definitely sufficient for our needs. We will no need nowhere near that for this particular design.
(1:00:52) With that being said, before we do all these connections, as usual, let's assign the footprint. Let's assign the part parameters. And again, I keep repeating this, but I strongly suggest making your own schematic symbol library so you don't have to do this all the time. Double click on the part. Let's assign a footprint. Click on the footprint library symbol. Expand the connector to USB. And there's many, many different options available.
(1:01:08) Option that is very cheap, very reliable. I've used in a quite a number of different designs is this GCT USB 4105, which is an SMD mount with throughhole shield pins for a slight bit of mechanical rigidity. So, let's just go with that one. You can see this is also a 16 pin part. I'll double click on that.
(1:01:28) You have to, of course, fill in the other information, which I'll do in my own time, but for now, I'll just click okay. With that now in place, let's start off before we go to the USB to converter. Let's start off with the power cuz that of course will power the rest of this board. So, I'm just going to move this a tiny bit up. And the first thing we want to do is add in some ESD protection.
(1:01:46) Any external connection in my eyes should have ESD protection right to the connector. Filtering if you need it. Of course, for a demo board, for a little test board like this, maybe not entirely necessary because oftent times these microcontrollers have built-in ESD protection and you're not, at least for this type of board, worried about passing any CEC tests, EMC testing because this is just to maybe evaluate the microcontroller or your circuitry.
(1:02:10) But for commercial designs, ESD protection filtering is of course a must. We will reduce this down a tiny bit. One of my favorite ESD protection packages is by ST Micro Electronics. If I click on A on my keyboard, add a new part USB LC typed in the filter bar. There are these integrated packages for USB 2.0 highspeed.
(1:02:28) We are only using full speed in this design, but these contain various TVs, so transient voltage to pressure dodes, ESD protection diodes that will place very near this connector. Again, anything that connects to the external world should have ESD protection in pretty much most cases. There are various different flavors of this. I prefer the USB LC6-2 SC6.
(1:02:48) Again, this is for USB 2.0 highspeed. So, it has very low capacitance diodes for the data lines and it also protects the VB bus line. So, I'll double click on that, add that in, and I'll place it somewhat close to the D minus D plus lines like so. Pin five is the TVS diode that protects Vbus. Pin two is the ground side. So, I'm going to copy one of these ground symbols, tie that to pin 2.
(1:03:12) And the data, I can already tie the left hand side to pin one, D minus, and D plus to pin 3. And because we're running USB full speed and the USB type-C jack and cable can be plugged in both ways, so rotated 180Â° or rotated 0 degrees, that means we have two sets of every pin. We've got D minus twice, got D+ twice, got CC twice, SPU twice, ground twice, and VB bus twice.
(1:03:37) However, if you're running USB high to USB full speed, you can simply just tie the D minus pins together straight away. It'll leave short stubs when we come to the PCB design, but that's completely fine for USB highsp speeded USB full speed. I've never had any issues without simply tying the connections like so. And again, this is because the USBC type receptacle can be plugged in two ways for the same connections.
(1:03:55) So, we need double the amount of pins. So, now we've hooked this up to this small ESD protection device. And in the PCB design later on, we will see this is placed close to the connector. And this is again specifically for USB 2.0. Protects VBUS and protects D minus D+. So, we have our connector ESD protection.
(1:04:13) And what I'd like to do now is then feed into a small PI filter on the VB bus line. The first thing I'd like to do is place a power flag on the VB bus line. So I press P and we want a power symbol. So let's see what other power symbols there are because it's nominally 5 V, but it can drop down to 4.5 volt.
(1:04:32) It can go up to 5.5 volt. So therefore, you might want to use a power symbol that's called Vbus because we have a quite a large 500 m volts either way voltage range. If I double click on VBUS, I can place that just above the line. Press escape, click and click to connect the Vbus power flag to the Vbus line. And again, this is also for giving this net a net label.
(1:04:53) What I also like to do for positive going nets, I always add a plus before the net voltage or the net name. And that's simply when I sort the nets by name, all my positive going nets will be listed together. So that's why I find that very useful. I'm just going to move net label down by pressing M. And there we go. Now let's add in that pi filter. A pi filter effectively consists of a capacitor. So I'll take one of these capacitors.
(1:05:11) It consists of a series element. In this case, I'm just going to take a placeholder zero and resistor.trl Ctrl +V R to rotate. Connect that part up on the left hand side. Copy this structure. Select and drag. Crl + Crl + V. Place on that side. Click on the capacitor. Just X to rotate and mirror to get it like so. Then we need the ground connections.
(1:05:31) So we're going to copy this structure. Place it over here like so. And on the C8 capacitor like so. Then we feed we're pressing W to start the wire command from our Vbus connection to our PI filter input. So we have a V-bus connector. We feed past the capacitor through a series element past the capacitor. The PI filter is basically a birectional filter.
(1:05:50) So we have filtering action going from left to right but also from right to left. So if we populate the resistor for example with a 1 ohm resistor, we have a 1 / 2 pi * R * C lowass filter going from left to right but also in the other direction.
(1:06:09) This means noise that's on the Vbus line externally will be filtered going into our board, but also any noise that's produced and generated on our board and popped on the Vbus line will also be filtered out on the left hand direction. You can see I've used fairly placeholder, fairly generic components on this PI filter. A fairly small amount of capacitance and a zero ohm resistor. This I always like to place just as a placeholder.
(1:06:26) It could very well be that you don't need this PI filter. But if you do need this PI filter and you don't have it in place, it's a real pain to add that later. You'll have to do another board spin. You might have to do some sort of flying wire contraption on your Rev Aboard. So, I'd rather have in a PI filter if I might think I might need it.
(1:06:43) I can always get rid of it or just do not place these parts later on as well, but I think it's very useful for testing. So, on my VBS line, we have this small placeholder PI filter. And after that, we have our filtered VB bus, which we need to feed into a voltage regulator that generates our 3.3 volt rail.
(1:07:00) Just to clean this up a tiny bit, I'm actually going to controll X this VB bus and just move it maybe something like this. Of course, you can make your schematics prettier. I try to avoid using many floating net labels and global ports. If you can make it nice and connected with these wires, you don't want many of these zigzag crossings and things jumping over each other. Make it fairly clean. Use global ports and net labels when you need to.
(1:07:17) In any case, now we have our filtered output. So, I can compress W to start the wire command and just lead that wire out a tiny bit. Now, we need a voltage regulator. Again, stepping down our Vbus, which is normally 5 volts, but it can go down to 4.5 and up to 5.5 volt. So, we want to step that down to 3.3 volts.
(1:07:36) There's a couple ways of doing that. The two obvious choices might be a linear or low dropout linear regulator, which typically isn't as efficient as, for instance, a buck or switching regulator. Switching regulators are more complex typically to implement. Maybe it's more costly because you have more external circuitry, but of course they can be more efficient.
(1:07:54) And a linear regulator is typically very easy to implement. Input capacitor, linear regulator, output capacitor, maybe a small feedback network, and you're done. So that's exactly what we're going to do. So we're going to add part again by pressing A on the keyboard. One of my favorite linear regulators, fairly generic Jellybean part, not terribly expensive, is the SPX 3819.
(1:08:11) This comes in various different flavors. This is also a very nice part for analog supplies because for the non-adjustable version for instance for this 3.3 volt version there's a bypass pin on pin 4 which you can add external capacitance to which brings down the overall voltage noise level of the regulator part I strongly suggest using in designs where it fits it's high current up to 500 milliamps you can get fixed output voltage variance varied output variance it's fairly low noise fairly cheap and I think it goes up to about 15 16 volts of the input voltage which of course we
(1:08:41) don't need in this case but it's a useful part to have. So double click on this and we can add that in. So I'm going to place it somewhere here. If we look at the day sheet for this part, we need to see what capacitance we need at the input and output. We can see here they require a minimum 2.
(1:09:00) 2 microfarad aluminium electrolytic, but it can also be stable with a 1 microfarad tantelum capacitor. Now the question is because we have multi-layer ceramic capacitors sometimes with older low dropout or linear regulators that can cause issues with stability. However, if we look at a separate document, the SPX 3819 FAQ, we can see that there's a question, can ceramic capacitors be used on the output? And they may be used for this part.
(1:09:20) And the recommendation is to, of course, keep the equivalent series resistance of the capacitor as small as possible. And that's typically the case for these small multi-layer ceramic capacitors. So, we saw a minimum value of about 1 or 2 microfarads. So, what we're going to do is just reuse this 10 microfarad capacitor we have to design anyway, and that won't increase the length of our bill of materials. So, I'm going to copy that, paste it here.
(1:09:39) Let me just move the parts around a tiny bit. Running out a bit out of a space. And I'm just using the same commands as usual. We're feeding in from the PI filter through my input pin one of the regulator connecting my input capacitor to my input pin. The enable pin. If we look at the data sheet for the SPX 3819, we can see the voltage can be anywhere from 0 volts to VIN.
(1:09:58) That's the allowed voltage range. Of course, we want this part to turn on. So, therefore, we will just tie the nail pin straight to the input voltage pin. We're only expecting up to 5.5 volt. So we're completely fine in that input voltage range. The ground pin we connect to ground. We need an output capacitor which will use also 10 microfarad at the output.
(1:10:15) Let me just move this microcontroller around. So all I'm doing is clicking, dragging, shift clicking, dragging to select more parts. And then I can press M to move. And let me just move this a bit to the right hand side to give us a bit more space. Now I can click and drag. Press M to move. Move the a capacitor to the right a bit. Now we have this bypass pin.
(1:10:34) Again, if we add some external capacitance to that pin, 10 to 100 nanofarad, typically that can reduce the output voltage noise on the output rail of this SPX 3819 regulator. For this particular design, we're running pretty much purely digital. We're not really worried that much unless it's very excessive about the output voltage noise.
(1:10:52) So, we could leave this pin floating, but we could also just attach, for example, a 470 nanofarad capacitor because that's what we already have in the design. So, I can add that in here. That's now attached to the bypass pin. Now, the output voltage still needs a net flag, and that's going to be 3.3 volts. Keep in mind, this is internally compensated, internally regulated to be 3.3 volts.
(1:11:10) So, therefore, we just tied it in like so. We're almost ready, but you might have already noticed we're missing a net flag after the PI filter. So, I'm going just copy VBUS, put it after the PI filter, connect it to our line, change the net label by double clicking, and adding an F for filtered.
(1:11:28) So our power rail, our power network currently very simple and it'll pretty much stay that simple. Vbus feeding into a small PI filter little placeholder input capacitor for the low dropout linear regulator dropout linear regulator output capacitor and in this case of this particular regulator we can add in this bypass capacitor here.
(1:11:45) And this is how we then generate our power supply power source our 3.3 volt rail that actually now powers this microcontroller. Let's finish up the remaining connections of the USB type-C connector. We of course need ground and typically it's recommended also by the USB type-C spec for devices to tie the shield to ground. Often times there might be recommendations to tie through a high voltage capacitor. The shield to system ground.
(1:12:10) I fed pretty well also during EMC testing just to tie the shield directly to system ground as well. So that's what we're doing here. The sideband use pins are unused and right now they are just looking like they're floating. KiCAD essentially expects us to tie these to some other node or some other net.
(1:12:28) But we want to explicitly tell KiCAD that these pins will not be connected and it shouldn't throw any errors later on when we come to the electrical rules check. The way we can do that is on the right hand side you see this little X and that's a place no connect flag. That tells KiCAD, yep, we've checked those pins. These will not be connected to anything. Please ignore these pins.
(1:12:45) So you can either click on this button on the right hand side or press Q on your keyboard while hovering over the pins and that in places this no connect flag. Press escape to cancel and now we have not connected by used pins and I'd strongly suggest you do that for all unused pins in your design.
(1:13:02) We still have the CC1 and CC2 pins and as we spoke about earlier these need to typically have 5.1 koohm pull down resistors to invoke the very very basic essentially almost non-negotiated power delivery requirements for type-C if a type-C host is connected. And that's also the reason previously we used a 5k1 pull-up resistor for the end reset line is because I just want to simply reuse the 5.
(1:13:24) 1 koohm resistor for the CC1 CC2 pins because that's a fairly precise value we need for those. So I'll just place one there and I need a separate one connected to CC1. So you can't just share one 5K1 pull down resistor between CC1 CC2. They need to be their own separate pins. You can see I'm going to get in the way of this ESD protection. So I'm just going to select these components. Press M.
(1:13:42) move this out a bit and connect these pins back up again so that I can connect CC1 to my resistor. And I'm simply going to have my ground connection like so. And that way my CC1 CC2 pins are connected. Again, net labels, net labels, net labels for the D minus, D+, and CC1, CC2, we're still missing net labels as well.
(1:14:01) So I can press L. And for KiCAD to recognize this differential pair, because we have a differential pair D minus, D+, they need to be rooted in a certain way. And we'll see that when we get to the PCB design. We need to give a clue to Keycat to treat them as a differential pair.
(1:14:19) So the D minus I'm going to call it USB D minus explicitly with a minus at the end. Place that on this line. And I'll just copy that. Ctrl + C crl + V. And I'll call that USB D plus for the data plus line. The same net name. So USBD on both lines. And then minus plus is enough to tell KiCAD that this is a differential pair. We also have the CC1 CC2 lines. Let me move these out a bit. Select the whole thing.
(1:14:38) And I can simply click and drag with a mouse as well to leave enough space for the net labels. Copy. This is going to be USB CC1. Copy that again. That's going to be USB CC2. As we've now taken care of our power source on our USB connector, at least for the most part, before we get over to deciding on the pin out, for example, hooking up a UART USB converter and doing maybe a small pin out to a small header for some generic IO, we of course need a way of programming this microcontroller. Typically you might use something such as JTAG but a very common
(1:15:08) lower pin count option is serial wire debug. If we zoom in on the MSPM0 microcontroller we can see we have dedicated pins 34 and pin 35 that are dedicated to serial wire data input output and pin 35 is dedicated to serial wire clock. Those two pins plus ground typically plus your reference voltage in our case VDD 3.
(1:15:31) 3 volts is enough for a programmer to be able to correctly program and debug and communicate with this microcontroller using serial wire debug. But I also strongly suggest always adding in the end reset signal. You could of course add a switch, a physical tactile switch for instance that pulls in reset low, but I'd strongly suggest also hooking that up to a debugger. The debug interface, there's various different standards.
(1:15:55) There's 10 pin, six pin, 20 pin, quite a few maybe somewhat confusing standards of how to hook up to a header that then connects to a debugger, a programmer. For instance, just looking for ARM SWD header, which typically will give you the pin out. We can see for instance, we might use a 10pin 1.27 mm pitch header with the configuration like so. So, we have VCC or VDD in our case, grounds, reset, serial wire, DIIO, serial wire, clock.
(1:16:18) That might be one of the standard pinouts. And you're of course more than welcome to use the one that fits your debugger. What I prefer is just getting one of these Tag Connect TC 2030 cables. As you can see here on the one end, the right hand side, this plugs into the actual debugger, the programmer you use.
(1:16:36) And the left hand side simply is this pogo pin interface. You can you can get this without legs. You can get it with legs like this that clamp into effectively just solder pads. So there's no component on the actual PCB and you just need the interface cable between these set of pads on your PCB and those pads are of course free or they are part of the printed circuit board through the cable and then into whatever debugger you use for your particular microcontroller.
(1:17:00) So this is the option I will be going with. The TC2030 IDC type cable is the one that fits for my particular use case and the footprint is actually already in KeyCat as well. In terms of what actual debugger and programming tool you use, there are a few different options available.
(1:17:17) For example, looking at the Texas Instruments MSPMO tools guide, they have a section on debugging and programming tools. For instance, you can use an XDS110, MSP Gang, and various other tools you can find on this site here. And these are predominantly TI's own programming tools that you can see here. Depends on if you just want to program TI based parts or you actually want to program different types of ARM cores, you might want a different solution. What I actually use is a Sega JLink.
(1:17:41) Now, the Sega JLinks, depending on what version you use, what product you use, can get a bit expensive. So, they sometimes are a bit prohibitive, but they do work with various different ARM calls and different processors. They have a comparison table on their website, which shows you what calls you can work with, and you can also look at the supported devices on the Sega web page.
(1:18:01) Type in MSPM0, and you can see which JLink, which Sega product you can use to program the various devices. You simply just need to look for something that can program a Cortex M0. In essence, in any case, let's add in that debug interface connection. Again, you feel free to use whatever interface you think is appropriate. You could make your own adapter, whatever you need.
(1:18:19) I'm going to go with the Tag Connect TC2030 as before. So, I'm going to click A to add a pot. Then look for TC 2030 or TC2030. There are different models available. We saw the one without legs, so without these clip-in legs, which needs a separate retainer spring, which is okay for smaller devices, but I prefer the standard TC2030, which has these larger holes, which means I don't need a retaining clip on the on the other side of the PCB. That's what the one I'll take.
(1:18:44) And the nice thing is this is also linked to footprint. Keep in mind, this is not actually a component. So, this won't have to be sourced or assembled by the manufacturer of the PCB, but you do need that interface cable, but other than that, there's no actual expense to using these other than getting the cable. and of course the debugger which you need in any case. So click okay.
(1:19:05) Nicely enough the symbol already exists but again I'd like to do a tiny bit of rearranging. Before we do the rearranging we can see what pins we need to connect. So we need a power reference. We need ground. The reset pin as we said before can be optional but I'd like to connect it. We have serial wire clock serow wire data input output.
(1:19:22) And we also have this trace this S swo pin which you can connect to certain market controllers which provides extra debugging capabilities. But as a base minimum, we want pin one, pin five, pin four, and pin two connected. But let me just rearrange them a tiny bit to make it a bit easier with this particular schematic. So the same thing as before. Double click on the symbol, click edit symbol, and then we just have to move these pins around.
(1:19:41) I've adjusted the symbol like so. So the top I have VCC pin one. Bottom I've got pin five, which is ground. And on the right hand side in order I've got serial wire DIIO and serial wire clock the trace pin which is also known as S swo as well as the N reset the inverted logic reset pin on pin 3. This T connect TC2030 symbol.
(1:20:01) I then simply hooked up straight into the serial RDIO and clock pins and rooted the reset pin into our end reset construction that we saw earlier with a pull-up resistor and this filtering capacitor.
(1:20:17) Some microcontrollers offer a trace output and sometimes it can be very helpful to connect the trace this swo pin pin six but for now I've left this unconnected and used the no ERC flag on pin 6 which you can access through Q on your keyboard which tells KiCAD to ignore any violations on this pin because we are not connecting this to anything else. Keep in mind this symbol as well. If we double click on it, it's important as is default for the KiCAD library that it's excluded from the bill of materials.
(1:20:39) And we can see that in this little attributes box at the bottom middle section of the symbol properties panel because this is not actually a real component. It's basically just exposed pads on a printed circuit board. So it should not be assembled or manufactured or sourced in any way by the manufacturer. But that's how easy it is then to connect up the serial wire debug connection.
(1:20:58) One option we saw earlier to attribute various signal types and various peripherals to the various pins on the microcontroller is using the data sheet. As we saw on page 11 of the data sheet table 6-2 looking at the pin attribute section, this is what we use to create the schematic symbol for the microcontroller.
(1:21:17) Here we also saw that the various pin names and pin numbers on the various package types. We can see what type of IO it is. So if it's five tolerant, if we can do open drain on that pin, but also what signals we have. For instance, PA N can be UAD Nord TX SDA could be a timer and much much more. So you could go through mix and match these pins.
(1:21:36) For example, use PA N and P1 for UART TX and UART RX. That is definitely one valid option to doing so. Another option I personally prefer is when it's available from various manufacturers is using their IDE. Often times there's a configuration interface and often times it's a graphical one as well. We looked at this at the start of this video.
(1:21:56) This is this code composer studio CC studio by Texas Instruments which is a free IDE also for use with these MSPM parts. You can use an online version which runs in your browser or just download it offline. That's exactly what I've done. So I've opened up code composer studio here. What we can do is go to the top left file create new project and then we can select a device.
(1:22:17) I'm going to type in my MSPM G3507 which is the family of microcontrollers we're using for this board. And I can select the device. You can also see here a pre-made Texas Instrument launchpad. So, a development or evaluation board is also available. So, you could also when you're creating your own hardware, of course, reference those designs if you wish, but we'll just go with the device because we're making an entirely custom board. You can choose a template for the project if you'd like. We'll just get started with an empty project as well.
(1:22:40) For instance, let's just start with a GPIO toggle output. For us currently, it doesn't really matter. We just want to use this to figure out the pin out of our microcontroller. We need to select a compiler. I'm just going to go with a GCC compiler, no arttos, and click create.
(1:22:56) Code Composer Studio and the peripheral setup is something we'll see again later on or perhaps in a new video dedicated to the firmware for this particular demo board. But for now, once you've created your project and once you've installed the relevant files that code composer studio wants you to for the relevant package you're using.
(1:23:15) So for instance, for this MSPM G3507, I had to download an extra package, but code composer studio guides you through that. But you can immediately see that in code composer studio it's a fairly graphical interface in the CIS config view which is opened automatically. We can go through the various peripherals on this lefthand panel such as I squed C spi art and so on and configure them fairly graphically.
(1:23:34) On the right hand side we can also see the package view but right now the package is the wrong type. It's the LQFP 64 package and we actually want a 48 pin package. So I can click on the switch button on the right hand side. It's still the same part but it's a different package number. the PT, so it's the LKFP 48 package.
(1:23:52) Click confirm and that'll just adjust the package and also the peripherals of course because we have slightly less pins. We can see from this view on the bottom right hand side various pins are colored differently. So the generic IO are just these grayish pins. We have green pins for example here which are sign pins. So we have serial wire clock serow DIO and we have these red pins.
(1:24:11) So Vcore 48 and VDD pin 6. Pin 7 is our VSSs our ground pin. But the rest of the pins are pretty much free for us to assign. So of course we need power and ground. And of course we need our programming interface as we just did. If we want to then start assigning other pins, we can either hover over let's say pin 42. You can see that's PB24.
(1:24:30) And we can see what various pin functionality there is. So it could be an ADC pin, it could be an SPIO chip select, it could be a timer pin. And this is exactly the information that's then also reflected in the data sheet. If you want to set up a peripheral, let's say you want to set up UART, you could go onto the left hand side, click UART, either click the plus next to UART or click at the top that blue button add. We can see it's defaulted to select peripheral UART1. We can choose a quick profile which sets up a board rate,
(1:24:54) which it sets up what clock pin we might want to use. And on the right hand side, we can see the highlighted pins. It's automatically selected pin 33 for UAT1 RX and pin 32 for UAT1 TX. You can move these pins around as far as the device allows by going to the bottom, looking at pinmucks, peripheral and pin configuration, expanding that, selecting what peripheral you might want to use.
(1:25:16) So it can use up to four UATs for this particular device. Then you can choose what RX pin it should be on. So currently it's on PA18. So that's pin 33. If I expand that, it can be on any of these pins that are listed here. And similarly for the TX pin, again, it could be any of these pins here.
(1:25:36) If I select PA N for the TX pin, Cocoza Studio automatically adjusts the UR peripheral to be UART zero. So it's not just staying within the previously set UART 1 for instance. And it also moved the RX pin around to fit UART N. So right now we can see here pin one is UAT N TX, pin 2 is UART N RX. Those might be pins depends on how your PCB layout is, how your PCB routing is, and what other IO you need.
(1:25:57) These could be perfectly fine UART pins and we can verify it using the data sheet or for instance using code composer studio. What you can of course also add for UART is flow control pins. So we could go to the basic configuration section and enable both RTS and CTS for instance if your USB to UR converter or whatever peripheral you use supports that.
(1:26:15) So if I click on that then again new pins are selected. So we have pin 30 for RTS and pin 29 for CTS. Those are essentially the basics for setting up pins and choosing peripherals using code composer studio for these TI microcontrollers.
(1:26:34) You can of course do the same thing for I squ C for the ADCs for the clocks and so on. It's a very simple fairly easy to use graphical user interface and that information then for instance that pin one is N TX pin 2 is U N RX you would then simply transfer to KiCAD. So going back to the schematic, I would simply create a wire for for example from pin one.
(1:26:53) Place a net label by pressing L and then say that's u n TX and I can copy that structure and paste it on pin 2 and simply change the T to an R because that's the RX pin. So pin 2 is PA1, pin one is TX, pin 2 is RX. Now that we have a basic idea of how we can set up pins, let's now add in our USB to UART peripheral or converter IC.
(1:27:17) In terms of USB to UART converters, there are many different choices. Many different companies make these types of products, and they're usually very, very easy to integrate into your own designs. Again, it's a shame that this series of microcontrollers doesn't integrate a USB 2.0 interface directly, but fair enough given the price point and probably the target market for this part.
(1:27:35) In any case, what we could do is incorporate an FTDI based solution. Very well-known, very much used part. There's parts such as the FT232, USB 2.0 0 to UAT converter up to 1 megabit per second and work to the IO levels we want. However, typically rather pricey. So, they're listing $6. You can typically get it a bit cheaper, but very pricey. There are other alternatives.
(1:27:58) For instance, the one we're going to be using is this super inexpensive, really easy to use Chinese USB to URL converter. This is the CH340E. And Sparkf fun, I believe, and Adafruit, I believe they sell these as well, at least as little test or demo boards. And I've used them for simpler, cheaper products as well. They're very, very straightforward, super easy to use.
(1:28:16) And you can see even the low quantities at 65 cents per piece or in the thousands at about 38 cents per piece. These are super cheap. Here's a translation of the data sheet. And we can use this to then figure out what connectivity we need. And also, if we need to create the symbol and footprint, we can use the data sheet as before to generate that information.
(1:28:32) The particular IC we're using is the CH340E, which comes in MSOP-10 package. So very standard, straightforward package. So KiCAD will most likely have that already. We have the pin config as well. So we need the MSOP column. We have VCC which is our power input. We have ground. We have the data plus data minus for the USB. We have TX RSCTS RTS pins.
(1:28:56) So we can use the hardware flow control signals as well. And they also have a pin on this package called the T now pin which you can connect up to an LED to which indicates data transmission which can be useful feature for debugging for instance. Operating conditions we had the VCC pin. The data sheet tells us to connect VCC to the input external power. So that is the same as 3.
(1:29:14) 3 volt if we're using a 3.3 volt supply for VCC. Otherwise, the V3 is actually a supply output. And then if we're running VCC of 5 volts, we just need to attach a decoupling capacitor to V3 and not connect it to anything. So what we can do is simply tie V3 and VCC to 3.3 volts. And as we can see here, the VCC supply voltage V3 is connected to VCC. For the E variant of this part, 3.
(1:29:38) 3 volts is fine because we have that as the system voltage anyway. And then that's okay with our IO levels connected to the microcontroller. You always want to match your IO levels, of course. So, going back to KiCAD, what we have to do again, as usual, is just add a part, press A, and hope that the CH340E is already in there. And what a surprise, it actually already is.
(1:29:57) It also has the correct footprint assigned to it. So, we can double click on that to add it into the design. and we can place it somewhere hopefully sensible. Like so. Press M on the designator to move this a bit around, make it a tiny bit cleaner. Then all we have to do is hook up the USB D plus to D plus USB D minus to D minus. You can see they're flipped here.
(1:30:16) So what we could do, of course, is just edit the symbol. Now I wouldn't always suggest editing the symbol just because it fits well with your schematic. It might make things easier, but you can of course allow crosses. This is not like something you can't do. So I'm just going to connect D+ to D+.
(1:30:30) I'm going to connect D minus to D minus like so. I'm going to connect ground pin to ground. Now VCC in V3 we are going to tie together as according to the data sheet to 3.3 volts which we're getting from our regulator we added in at the top previously. And I'm going to place one 470 nanopharad capacitor per pin.
(1:30:50) So one for fin 7 and one for pin 10 to ground. It's a typical recommendation. One decoupling capacitor per power supply pin. It's getting a bit cramped here. So, let me just move components around a bit. All I'm doing is going to drag. Press M to move. I'm just going to clean this up a tiny bit before we continue. So, here we are. I just moved things around a tiny bit just to give me myself a bit more space.
(1:31:09) Let me grab one of these 470 nanopharad capacitors. And again, the data sheet says 100 nanofarads, but we're doing bill of materials consolidation. I don't want to have a million different items on the bill of materials. The actual value of the capacitance, at least for this type of board, isn't that critical for this type of circuitry. So, I'm just going to reuse the capacitors I already have from the design.
(1:31:27) connect ground to one side. As usual, these are bypass decoupling capacitors and then connect VCC and V3 together and then of course supply 3.3 volts to both of those pins as according to the data sheet. Again, you can run VCC from 5 volts from our Vbus F directly and just disconnect V3 and only connect V3 without any power source to a decoupling capacitor.
(1:31:52) That's fine as well if you don't have an external 3.3 volt source for instance. Okay, so those connections to the USB differential pair are made. We've got our 3.3 volt net feeding VCC and V3. And now of course we want UAT TX u RX to connect to this device. So we want TX connecting to RX and RX connecting to TX. The pairs need to be crossed. And this is a typical mistake that people do.
(1:32:15) Oftenimes it can be helpful to place zero ohm resistors or interchangeable resistors on the TX and RX lines in case you accidentally do one of those crossings or in case you need series termination resistors. But typically for UART for short lines as we'll have on this board, I just do pointto-point connections and just make sure I've checked that TX goes to RX and RX goes to TX. So we have TX that goes to RX and we have RX that goes to TX. Like so.
(1:32:37) Of course, we could clean this up a tiny bit. We'll move some net labels around as well, maybe to give oursel a bit more space that things aren't that cramped. But again, this is just initial start for the schematic. I would like to move these labels down a bit so they don't interfere with these lines. So I'm just clicking on these and pressing M. Just cleaning up the schematic as we go.
(1:32:54) We can of course do this at the end, but a tiny bit of housekeeping goes a long way. We have CTS and RTS as well, which we need to connect to the microcontroller pins. Going back to code composer studio, looking at our UART, we can see that we can either use PA8 or PA15. So that's pin 16 or pin 30 for RTS. Or for CTS, we can use pin 17, 29 or 38.
(1:33:18) So we want something on the same side as the UR N TX and RX pins. So ideally, we'd want something close to pins 1 and two. Just thinking ahead to our PCB design. So something that's in that same vicinity. There isn't something that's terribly close. Maybe one of the closer ones are PA88. So that's pin 16. That moves at least the RTS pin a bit closer.
(1:33:37) And the CTS, you might move that to PA9, which is pin 17. So they're kind of on the same side of a package. So it can be very useful when you have flexibility in your microcontroller or if you're using an FPGA to map pins already when you're thinking about hardware schematics, thinking about the PCB design as well. So let me just clean up the schematic a tiny bit.
(1:33:56) Give ourselves a tiny bit of space cuz we need access to pin 16 and 17. So adding in a net label UN RTS that's pin 16 and we have UAT N CTS that's 17. Press escape to cancel the command. Wire that up to pins 16 and 17. And same as TX and RX, we had that crossing between one device to the other. So TX goes to RX, RX goes to TX and vice versa.
(1:34:19) We need the same thing for RTS and CTS. So I'll take CTS and that goes to RTS and I'll take RTS on one end and that goes to the CTS of the other end as well. So keep in mind those crossings are of course important as well. Now we have all the USB and D connections hooked up. We do also have this T now pin for the CH340E and that again according to the data sheet can be used to highlight ongoing data transmission and this is active high. So we could tie an LED through a resistor to ground and tie that to that pin to indicate the data transmission.
(1:34:51) If you want, that's of course fine. You can also tie that to an MCU pin. We're just going to leave that disconnected for now. And I'm just going to press Q above pin six because that indicates again that this is a no ERC flag. The rules check later on. We'll be ignoring that pin because it's not connected. Lastly, you've probably noticed, but we also need net names.
(1:35:09) Well, we don't need, but I prefer to add net names or net labels to pin one and pin two. So, I'm just going to copy the USB ones. And again, we want the minus and plus endings, but we need different net names. Although they are the same signal, they are passing through this block U2.
(1:35:30) So I'm actually going to change the USBC connector net name to be USBC D minus and USB CD plus just to get that distinction between them. But still we want minus and plus at the end to tell KiCAD that this is a differential pair. For instance, moving back to code composer studio just having a little scan around the part. What we could do is for instance on pin 14 we can see we have I squed C1CL.
(1:35:48) In 15 we can see we have I squed C SDA. So we could do an Scccl SDA I squ C pair. We need to apply the appropriate pull-ups and route that to a header is something we could do for instance. That way you can also scan around the part look at which pins you need.
(1:36:06) For example, pin 32 has an ADC or another UART and then lead that out to either onboard peripherals or to external peripherals as well. Or instead of connecting to a header, let's actually go with connecting up an I squed C accelerometer maybe just for something slightly different. So I've just gone to back to the schematic again, pressed A to add a part and just tighten the start of accelerometer just to see what KiCAD already has so we don't have to create a schematic symbol or footprint.
(1:36:30) And I just found this LIS2DH 3axis accelerometer with an I squed C interface with a particular LGA land grid array 14pin package. Just checking to make sure that JLC or LCSC has it in stock as well and they do. So let's just use this part that we can have assembled as well. So I'm just going to add this part.
(1:36:48) And we already saw that pins PB2, PB3, so pins 14 and 15 seem to be suitable I squed C pins as well. So let me place it close to where we need to connect it to. Press escape. Then just cleaning up the schematic a tiny bit. We'll do more schematic cleanup later on as well before we move over to the PCB design. Let's briefly familiarize ourselves with the LIS 2DH.
(1:37:07) Again, this was a rather spontaneous decision, so we have to see if this actually works out. We can already see that our 3.3 volt supply is going to be okay. Most likely we have I squed C. This is a fairly low power device, so we're not terribly worried about power. Anyway, we can see the various pins we need to connect here.
(1:37:25) We have SDA, the device address, if it's I squed C or SPI mode. We have two interrupt pins and also VDDIO pin. So, let's just check if we can run that at 3.3 volts. And according to the electrical characteristics, we can. We're in the range of 1.7 to VDD plus 0.1. So, we can run both VDD and VDDIO at 3.3 volts.
(1:37:44) and we can hook up the interrupt pins because that might be useful because we might want to do some sort of DMA transfers or something. Looking at code composer studio, pin 14 is pin 15 is SDA. So, let me just align the part a bit better. Again, I've just moved some stuff around in the schematic again to give myself a bit more space on the right hand side. But we can hook up now the SCA STL lines and so on.
(1:38:03) And I am actually going to edit this symbol because also I'm not a fan of this particular layout. So, I've edited the symbol. Now let's move it bit into the right direction. VDD is our main power input. VDD IIO is essentially just setting the logic level voltage. So actually we only really need to decouple pin 8 rather than having two separate decoupling capacitors.
(1:38:24) The way we can see that also from the data sheet is looking at section three which is on page 20 of this particular data sheet. Well this accelerometer that pin 7 of VDDIO is connected straight to VDDIO. there's no decoupling or bypass capacitor whereas VDD actually has decoupling and bypass capacitors.
(1:38:42) So that's why for this particular scenario we can get away with just using one bypass decoupling capacitor connected to pin 8. But of course pin 7 VDDIO needs to be connected to 3.3 volts as well. So we're just going to connect both. But keep in mind that the coupling capacitor needs to be placed next to pin 8 rather than preferring to place it next to pin 7. We need a ground on pin 9 as well. So I'll just copy that. Paste that.
(1:39:02) That's now we have the power supply section of this accelerometer. Pin 14 is SCCl. Pin 15 is SDA. So, we're going to move that up a tiny bit. Connect pin 14 to SCCl. Pin 15 to SDA. And of course, as this is I squared C, we do need pull-ups to the logic level voltage, which is 3.3 volt. So, I'm just going to take the 5.1K pull-up resistor, which is an appropriate value for this fairly low speed interface. You're only at 3.3 volts.
(1:39:29) We need one for the SDA and one for theCL line like so. And of course, these need to be connected to 3.3 volts. That's exactly what we're doing here. So, we've got our I squed C pull-up resistors. Now, we need to figure out SDO and chip select. And as we can see, pin 3 SDO SA n this actually doubles as the I squed C less significant bit of the device. So, that sets the device address.
(1:39:51) If we had multiple different devices on this I squed C bus, then of course we need to pay more attention to what the actual address is. But given that we only have one device on this, I'm just going to tie SD N which also doubles as SCA to ground. And that just sets the least significant bit of the address with I squ C address. Then we have the CS pin, pin 4. And that if we're not using SPI, that actually determines also the I squed C SPI mode.
(1:40:11) So we want that to be a logic high. We want I squed C communication to be enabled. So I'm just going to tie that to 3.3 volts. Press R to rotate. Press M on the label. Rotate that as well. That wasn't rotated with it. and connect that the chip select line again which doubles as an SPI or I squed C select line. Then we have the two interrupts.
(1:40:30) We need to check if they're open drain or if they're pushpull interrupts. Sometimes you need to pay attention if you need a pull-up resist on the interrupt line. So let's just check that out. If we look at the pin descriptions, these pin descriptions aren't very helpful at all.
(1:40:43) It just says interrupt pin, which I guess we already know. But again, looking at the application hint section, there is no indication of any pull-ups on the interrupt lines. So I assume that it's going to be push pull. So, just because it's lined up nicely, we'll probably move these connections around because the interrupt pins just need to tie into inputs of the microcontroller and pretty much all of these pins are input capable, especially for 3.3 volt push pull.
(1:41:05) So, I'm just going to tie them for now straight to pins 22 and 23 just because they're nicely in line. Now, we're pretty much done hooking up this I squed C interface to this accelerometer, but we can't forget our net labels as usual. So, let me just go ahead and add them. For instance, something like this might be somewhat appropriate. Keep in mind it's a tiny bit cramped now.
(1:41:23) So you could move things around, clean up this schematic a tiny bit, but you can see pretty much unscraped connections. Of course, we have a lot of pins still remaining. We're not utilizing this micro controller in the slightest, but again, this is just for demonstration purposes. With the remaining free pins, we're going to just add the no ERC flag.
(1:41:42) So, I'm going to hover over, press Q, and go through the various pins and add the no ERC flag to all of the remaining pins because we're pretty much done at least with the electrical connectivity of the schematic. Now that we have net labels on all the parts, we have pretty much all the parts we need in. We've got our power supply section.
(1:41:59) Starting off with a USB type-C connector, ESD protection, PI filter, 3.3 volt LDO regulator, a USB to UART converter, which connects via UART with hardware flow control to our microcontroller. We've got our Tag Connect TC2030 serial wire debug header, N reset connection, and we've just added in an I squed C accelerometer just for the sake of having at least some peripherals on this board. This is pretty much all we need for a functioning schematic.
(1:42:23) Now, there's a couple things I would like to add and maybe adjust with the schematic. The first thing is the designation. As you saw, every time we add a part to the board to the schematic, KiCAD automatically assigns a number. So, for example, R4 here, we have U2 here, C13, C12. And the way this is done, of course, it's thinking it's sequential. I don't think this is particularly great.
(1:42:42) So, I would like to reanotate the schematic. So I'd like to have a logical sequence of component designators like you would read in the English language from left to right, top to bottom. That's the way I prefer annotating my designators. So what I could do is I could check double click on C7 and change that to C1.
(1:43:00) And then I could double click on C8, change that to C2, C3 and so on. I can do the same thing for the resistors, all the different parts and so on. Of course, rather tedious, but there are also automated tools that can do that for you. For instance, at the top toolbar, you can see I'm hovering over the annotate schematic button. I click on that button.
(1:43:17) I can clear the annotation and then I can have various rules of how the schematic is annotated. I can sort the symbols by X position first, then Y position. I can change my numbers. I can only do the current schematic sheet and so on. Now, if I run this annotation, you can see the annotation here. It's maybe a tiny bit better.
(1:43:35) If I clear that annotation again and sort sort symbols by Y position, then do the annotation. This might be a bit better as well. it might be okay. But keep in mind this jump from R1 to R5 R six because we have resistors on the right hand side that isn't great either. Long story short, what I typically do, at least for KiCAD, which doesn't have particularly powerful or flexible annotation tools, is manually annotate the schematic.
(1:43:58) I just find I have a very finicky particular way of annotating my schematics and I'd like to keep that order. And the way KiCAD is currently, in my eyes, you can't really do that. So, I'm going to manually annotate the schematic as I've just shown you previously. So for instance like so I've gone through and annotated the schematic to at least to me it seems logical in mind doing things manually often introduces human error.
(1:44:16) You need to keep in mind that you can't have duplicate component designators. That's why in just a bit we'll be doing an electrical rules check. Another thing I've changed is the key default symbol here called this U1. So U to me is an integrated circuit and active device. That's why I changed that to D1 because this is a set of diodes and that's to me more logical.
(1:44:36) But other than that, this is pretty much the schematic. We could keep it, but again, there's still some things I would like to adjust and change. What I like to do is do text labels around bits of circuitry that, for example, an external person who's reviewing this, who's not familiar with the schematic, can instantly jump to certain sections just visually. For instance, I might say, "This is the USB connector section.
(1:44:55) This is the LDR regulator. This is the USB UR converter." Just adding little labels I find, is very useful, especially in the review process. The way you can do that is on the right hand side in the toolbar, click on the draw text button or just press T on your keyboard. That brings up the text properties dialogue. So what I can do is USBC connector.
(1:45:12) I can use the default font, change that to bold, maybe press okay. And we see right now I have this tiny bit of text which I can place down. That isn't great because it's not particularly visible. So I can double click on this and change the text size. Let's say let's try 250. That is maybe too large.
(1:45:33) So with a text size of let's say 100 units we have USBC connector at the top here and that just although it's fairly obvious to us of course now might help a reviewer and we can go through and add these labels by copy pasting or just pressing T to the board and that just helps the schematic be a bit more legible. So let me go through and fill all of that in and I hope you do that on your end as well.
(1:45:51) I've put these very simple labels in place and that's looking maybe a tiny bit better. What I also like to do and also do this for the PCB design is actually add net colors in addition to the net labels. Why I like to do that is especially for the PCB design you can immediately see if this is for example a very bright color for example a bright green this might be a high-speed net.
(1:46:09) If the color is gray this to me is a ground. If it's a red it might be a power supply net. It very easily visually lets you see what you need to be rooting why you need to be careful. For example, if there's cross talk between analog and digital traces, what you need to be careful, what you need to be pay attention to rather than zooming in on the various wires and trying to find the net label.
(1:46:25) So you can also add colors in the schematic and I typically do that by groups. So for example, all of the USB might be green, the powers might be red as we talked about. The way you can do that is by using net classes and we can access those by going to the top left, going to the schematic setup page under project net classes.
(1:46:43) They have this default net class where we can create our own net classes. Let's create one for USB. Then we can change properties such as the wire thickness, bus thickness, and so on, but also line style, but also the color that we want to assign to this net class. So I click on the color, and for USB, because it's somewhat of a fast digital signal, I'm going to do a fairly bright green.
(1:47:02) Click okay. That creates the net class, but it actually hasn't assigned anything to any of these net labels. And this also is a reason why we have net labels, why I like using them, because it's very easy then to assign all of these nets to a certain net class. So I can create a netclass assignment by using a pattern. So I'll click plus at the bottom here.
(1:47:19) My pattern is going to be forward slash USB star. And that then allows us to select all these USB nets using this pattern search tool. Net class. We're going to change to USB. Then I click okay. And you can see the schematic has updated. All of the relevant USB nets here have turned green.
(1:47:39) And we can immediately visually see okay this belongs to the USB net. Similarly we could do something for UART or we can do something for serial debug for the power nets and so on again using the net class assignment. So I'd strongly suggest you do that as well. So for instance that could look something like this then where we've assigned colors using net classes to all of the supply ground nets and also the IO nets as well.
(1:48:03) And to me that just makes it yes very colorful but also I think rather useful just quickly picking out certain parts of the design. And this will be especially important when we come to the PCB design. Okay, maybe for the schematic it's not that important but there's a good carryover to the PCB design. Now that we have all of this in place before we move over to the PCB design, there's still a couple things we have to do.
(1:48:20) One is what we talked about previously is to run an electrical rules check. The way we can do that is go to the top toolbar, click on this little electrical rules check button, and this will go through to see do we have nets with only one connection which are connected to something else. Is the power system set up correctly and so on.
(1:48:40) So if I just run the ERC, we can see we have a couple of violations and errors. If I click on the various warnings and errors, KiCAD will automatically jump to the relevant area. And you can also see we have these little red arrows that appear all over the schematic. So, it's important that you go through all of them, check them, and clear them if you can before moving over to the PCB design.
(1:48:57) You want essentially zero errors when you move over. First of all, pins of type power output and power output are connected together. And that's for symbol U1 and V3. And that's to do with the definition of the symbol by whoever created this KiCAD symbol that V3 as we saw from the data sheet for this USB to UA converter can be an output if you don't connect V3 to VCC to something like 3.3 volts.
(1:49:21) And it's complaining that okay, pin 10 is kind of defined as an output but the same as pin 5 of the LDR regulator. And of course if you tie two actual pin outputs together that's going to be a problem. Next one is a warning and that's because I've moved around the pins using the edit symbol property for this USBC connector.
(1:49:40) Next one is an error. Input power pin not driven by any output power pins. And the way you can solve those problems is by adding a power flag directive by going on the right hand side to place power symbol and looking for flag. And this power flag symbol you can see at the bottom of the description is a special symbol for telling ELC where power comes from.
(1:49:58) And we can just tie that to a suitable place. For instance, to the ground of the USB type-C connector because that strictly speaking is our actual power source. And I will hide the power flag value. Same thing goes for Vbus. We need to tell the ERC that that is where our power comes from.
(1:50:16) So I'll just copy the symbol, rotate, and just attach it anywhere on the Vbus line. We have the same thing for 3.3 volts because that now is also power source as well. Let's attach that here. And again, we have these two warnings that the symbol doesn't match any copy in the library. It's again because we move the pins around.
(1:50:34) Now, if we rerun the ERC, of course, we'll still have errors there again because power output and power output are connected and the symbols don't match together. What you can do once you've checked them and you really thoroughly have to check them and note these down. We can go rightclick and then exclude this violation. You can also exclude with a comment to say we've checked this.
(1:50:52) We've made sure to check the data sheet for the CH340E that we can type V3 straight to 3.3 volts and so on. We can also ignore these warnings by right-clicking exclude and so on. We can also edit the overall violation severities for right-clicking and we can say okay these should be warnings, these should be ignored, these should be errors and so on. And that's you can do in the schematic setup as well. But for now, we've checked all these.
(1:51:12) We've made sure these are okay. We can rightclick exclude or we can just continue. Before that, I'm just going to delete all markers and then click close. If you didn't assign footprints while creating the schematic or if your schematic symbol libraries don't automatically have footprints assigned to them, it's of course very important then to run the assign footprints tool which is also in the top.
(1:51:37) Because we did this while creating the schematic, if I click on the assign footprints tool, then we can see all of the footprints are already assigned. But it makes sense to go through this one more time just to check are all the footprints assigned? Are they assigned correctly? So all the 470 nanopharad capacitors have 603 the 10 microfarad 805 all the other various components such as integrated circuits or diode packages have the correct packages assigned and you could do the assignment here but I'd suggest creating your own schematic symbol libraries which automatically link to footprints. Then you can just click apply save schematic and continue. Click okay and
(1:52:06) this all seems to be in order. Another final step I'd like to add to the schematic is also add mounting holes which we'll most likely need on the printed circuit board as well as some fiducio markers as we'll see later on the printed circuit board.
(1:52:23) We need a minimum of three fiducio markers which are basically just exposed pads with a solder mask pulled back and that helps the assembler with alignment and positioning and placement of your printed circuit board. When it comes to assembly the way we can add these is as usual by pressing A on the keyboard or adding a part. First of all I would like to add the mounting holes. So I'm just going to look for mounting and we see there's different variations of the mounting hole available.
(1:52:41) Just a simple mounting hole with pad. So we can tie this for example to system ground and that's the one I want to use. You can also immediately select a default footprint with a little dropout dropown box on the right hand side below the symbol.
(1:52:59) So you can choose for example standard through hole mounting holes for example an M2 standard or an M3 with VAS and so on. So just as an initial guess I'm just going to go with the mounting hole M3 with VA in the pad. But I think they look quite nice and they're quite useful to use. So I'm just going to take one of these. And here you can see the footprint preview. Press okay. And that now adds in one of these mounting holes. And I'll just put this to the bottom left of the schematic.
(1:53:17) And you can see already if I place press escape to cancel the command, the mounting hole is of course grayed out cuz if you double click on it, it's excluded from the building materials. It's not an actual component. But I like to put it on the schematic to indicate that there are mounting holes on this board. I would like to change the designator though. H1. I'm going to change to MH1.
(1:53:34) So mounting hole one. and also mounting hole pad. I'm going to change the description to M3 so we know what type of mounting hole it is. Select it and I'm just going to paste four of these down. We might need less, we might need more, but just as a starting point. You can always edit this later. And I'm going to tie all of these to ground. So I've copied a ground symbol from before.
(1:53:51) And I'm just going to tie all of these mounting holes to the ground net. So we have nice ground mounting holes around the board, which we'll see later on when we come to the PCB design in the next video because they also provide good access points. For example, for oscilloscope ground clips as well or if you're tying this board or including this board in some sort of chassis.
(1:54:09) Fiduial markers, it's a similar process. We press A, look for fidutial, and we can also select the default footprint. As a standard future marker, I like to have a 1 mm fidutial with an exposed mask of 2 mm. So, I can just pre-select that footprint. And that of course isn't tied to anything. It's a I see a floating exposed copper pad.
(1:54:28) If you're doing double-sided assembly, you need three per side of the board. So, six in total as a minimum. We're probably just going to have components on one side on the top side of this board. So, that's why we only need three fedio markers. And put one down here. Press escape, select it, copy it, and paste it like so. There we go.
(1:54:46) Now, we've got four mounting holes, grounded, and three fidio markers, which we can then import onto the PCB later on. We don't have to add that then manually on the PCB. And I think it's a nice part to have as part of the schematic. With that being said, make sure to triple check your schematic before you move on to the next step, which is the PCB layout and routing.
(1:55:04) And that will be the content for the next video. In any case, I hope this video was useful and I hope it showed you the basics of integrating an MSP M0 microcontroller by Texas Instruments along with all of the other peripheral circuitry for very very simple demo board. The next video in this series and the last video of this series will then cover the actual PCB and layout PCB design.
(1:55:23) So that's layout and routting of this board of the schematic we just created and then also how we can get this board manufactured and fabricated by gelcb and I'll show you all the steps for exporting the manufacturing files getting them into gelcb with assembly and so on. And lastly we'll just do a little test of the board which you'll see here.
(1:55:41) So this is a slight variation of the one we created the schematic for today. I'll show you how to use Coco compar Studio as well as a Sega JLink debugger and programming tool then to flash some fur onto this board and prove to you that this design actually does work. Thank you very much for watching this first video in this two-part series of creating your own MSPM0 MCU based printed circuit board using KiCAD 9.
(1:56:05) If you like the video, please leave a like, a comment if you have any questions, and don't forget to subscribe to stay up to date with the next video in this series, as well as any hardware, PCB design, DSP, and embedded systems videos. Thanks a lot for watching, and I hope to see you in the next video.